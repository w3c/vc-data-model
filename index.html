<!DOCTYPE html>
<html>
  <head>
    <title>Verifiable Credentials Data Model v2.0</title>
    <meta http-equiv='Content-Type' content='text/html;charset=utf-8'/>
    <!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->
    <script src='https://www.w3.org/Tools/respec/respec-w3c' class='remove'></script>
    <script src="./common.js" class="remove"></script>
    <script class="remove"
      src="https://cdn.jsdelivr.net/gh/digitalbazaar/respec-vc@2.0.1/dist/main.js"></script>
    <script class="removeOnSave"
      src="https://unpkg.com/reqlist/lib/reqlist.js"></script>
    <link class="removeOnSave" rel="stylesheet" type="text/css"
      href="https://unpkg.com/reqlist/lib/reqlist.css" />

    <script class="remove">
      var respecConfig = {
        group: "vc",

        // specification status (e.g., WD, LCWD, NOTE, etc.). If in doubt use ED.
        specStatus: "WD",

        // the specification's short name, as in http://www.w3.org/TR/short-name/
        shortName: "vc-data-model-2.0",

        // subtitle for the spec
        //subtitle: "Expressing information with verifiable provenance",

        // if you wish the publication date to be other than today, set this
        //publishDate: "2023-12-21",
        //crEnd: "2024-02-28",
        //prEnd: "2019-10-01",
        implementationReportURI: "https://w3c.github.io/vc-data-model-2.0-test-suite/",
        //errata: "https://w3c.github.io/vc-data-model/errata.html",
        previousMaturity: "REC",
        previousPublishDate: "2022-03-03",

        // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
        // and its maturity status
        // previousPublishDate:  "1977-03-15",
        // previousMaturity:  "WD",

        // extend the bibliography entries
        localBiblio: vcwg.localBiblio,
        doJsonLd: true,

        // Uncomment these to use the respec extension that generates a list of
        //   normative statements:
        preProcess: [/*prepare_reqlist*/],
        postProcess: [
          restrictRefs,
          window.respecVc.createVcExamples
          /*add_reqlist_button*/
        ],

        github: "https://github.com/w3c/vc-data-model/",
        includePermalinks: false,

        // if there a publicly available Editor's Draft, this is the link
        edDraftURI: "https://w3c.github.io/vc-data-model/",

        // if this is a LCWD, uncomment and set the end of its review period
        // lcEnd: "2009-08-05",

        // editors, add as many as you like
        // only "name" is required
        editors: [
          { name: "Manu Sporny", url: "https://www.linkedin.com/in/manusporny/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
            note: "v1.0, v1.1, v2.0", w3cid: 41758},
          { name: "Ted Thibodeau Jr", url: "https://github.com/TallTed",
            company: "OpenLink Software", companyURL: "https://www.openlinksw.com/",
            note: "v2.0", w3cid: 42501},
          { name: "Ivan Herman", url: "https://www.w3.org/People/Ivan/",
            company: "W3C", companyURL: "https://www.w3.org",
            note: "v2.0", w3cid: 7382, orcid: "0000-0003-0782-2704"},
          { name: "Michael B. Jones", url: "https://self-issued.info/",
            company: "Invited Expert",
            note: "v2.0", w3cid: 38745},
          { name: "Gabe Cohen", url: "https://github.com/decentralgabe",
            company: "Block", companyURL: "https://block.xyz/",
            note: "v2.0", w3cid: 116851},
        ],
        formerEditors: [
          { name: "Grant Noble", url: "https://www.linkedin.com/in/grant-noble-8253994a/",
            company: "ConsenSys", companyURL: "https://consensys.net/",
            note: "v1.0", w3cid: 110600},
          { name: "Dave Longley", url: "https://github.com/dlongley",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
            note: "v1.0", w3cid: 48025},
          { name: "Daniel C. Burnett", url: "https://www.linkedin.com/in/daburnett/",
            company: "ConsenSys", companyURL: "https://consensys.net/",
            note: "v1.0", w3cid: 37473},
          { name: "Brent Zundel", url: "https://www.linkedin.com/in/bzundel/",
            company: "Evernym", companyURL: "https://www.evernym.com/",
            note: "v1.0", w3cid: 102128},
          { name: "Kyle Den Hartog", url: "https://www.linkedin.com/in/kyledenhartog/",
            company: "MATTR", companyURL: "https://mattr.global/",
            note: "v1.1", w3cid: 103517},
          { name: "Orie Steele", url: "https://github.com/OR13",
            company: "Transmute",
            companyURL: "https://www.transmute.industries/",
            note: "v2.0", w3cid: 109171},
          { name: "Oliver Terbu", url: "https://github.com/awoie",
            company: "Spruce Systems", companyURL: "https://spruceid.com/",
            note: "v2.0", w3cid: 110059}
        ],
        // authors, add as many as you like.
        // This is optional, uncomment if you have authors as well as editors.
        // only "name" is required. Same format as editors.
        authors:
        [
          { name: "Manu Sporny", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
            w3cid: 41758
          },
          { name: "Dave Longley", url: "https://digitalbazaar.com/",
            company: "Digital Bazaar", companyURL: "https://digitalbazaar.com/",
            w3cid: 48025
          },
          { name: "David Chadwick",
            url: "https://www.linkedin.com/in/davidwchadwick/",
            company: "Crossword Cybersecurity PLC",
            companyURL: "https://www.crosswordcybersecurity.com/",
            w3cid: 46156
          },
          { name: "Orie Steele", url: "https://github.com/OR13",
            company: "Transmute",
            companyURL: "https://www.transmute.industries/",
            note: "v2.0", w3cid: 109171}
        ],
        xref: ["URL", "I18N-GLOSSARY", "INFRA"],
        lint: { "informative-dfn": false },
        maxTocLevel: 2,
        inlineCSS: true
      };
    </script>
    <style>
code {
  color: rgb(199, 73, 0);
  font-weight: bold;
}
pre {
  overflow-x: auto;
  white-space: pre-wrap;
}
pre .highlight {
  font-weight: bold;
  color: Green;
}
pre .subject {
  font-weight: bold;
  color: RoyalBlue;
}
pre .property {
  font-weight: bold;
  color: DarkGoldenrod;
}
pre .comment {
  font-weight: bold;
  color: SteelBlue;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}
ol.algorithm {
  counter-reset: numsection;
  list-style-type: none;
}
ol.algorithm li {
  margin: 0.5em 0;
}
ol.algorithm li:before {
  font-weight: bold;
  counter-increment: numsection;
  content: counters(numsection, ".") ") ";
}
    </style>
  </head>
  <body>
    <section id='abstract'>
      <p>
[=Credentials=] are a part of our daily lives; driver's licenses are used to
assert that we are capable of operating a motor vehicle, university degrees
can be used to assert our level of education, and government-issued passports
enable us to travel between countries. This specification provides a mechanism
to express these sorts of [=credentials=] on the Web in a way that is
cryptographically secure, privacy respecting, and machine-verifiable.
      </p>
    </section>

    <section id='sotd'>
      <p>
The Working Group is actively seeking implementation feedback for this
specification. In order to exit the Candidate Recommendation phase, the
Working Group has set the requirement of at least two independent
implementations for each mandatory feature in the specification. Please see
the <a href="https://w3c.github.io/vc-data-model-2.0-test-suite/">
implementation report</a> for more details.
      </p>

      <p>
Comments regarding this specification are welcome at any time.
Please file issues directly on
<a href="https://github.com/w3c/vc-data-model/issues/">GitHub</a>,
or, if that is not possible, send them to
<a href="mailto:public-vc-comments@w3.org">public-vc-comments@w3.org</a>
(<a href="mailto:public-vc-comments-request@w3.org?subject=subscribe">subscribe</a>,
<a href="https://lists.w3.org/Archives/Public/public-vc-comments/">archives</a>).
      </p>

    </section>

    <section class="informative">
      <h2>Introduction</h2>

      <p>
[=Credentials=] are a part of our daily lives; driver's licenses are used to
assert that we are capable of operating a motor vehicle, university degrees
can be used to assert our level of education, and government-issued passports
enable us to travel between countries. These [=credentials=] provide
benefits to us when used in the physical world, but their use on the Web
continues to be elusive.
      </p>

      <p>
Currently it is difficult to express education qualifications, healthcare
data, financial account details, and other sorts of third-party [=verified=]
machine-readable personal information on the Web. The difficulty of expressing
digital [=credentials=] on the Web makes it challenging to receive the same
benefits through the Web that physical [=credentials=] provide us in the
physical world.
      </p>

      <p>
This specification provides a standard way to express [=credentials=] on the
Web in a way that is cryptographically secure, privacy respecting, and
machine-verifiable.
      </p>

      <p>
For those unfamiliar with the concepts related to
[=verifiable credentials=], the following sections provide an overview of:
      </p>

      <ul>
        <li>
The components that constitute a [=verifiable credential=]
        </li>
        <li>
The components that constitute a [=verifiable presentation=]
        </li>
        <li>
An ecosystem where [=verifiable credentials=] and
[=verifiable presentations=] are expected to be useful
        </li>
        <li>
The use cases and requirements that informed this specification.
        </li>
      </ul>

      <section class="informative">
        <h3>What is a Verifiable Credential?</h3>

        <p>
In the physical world, a [=credential=] might consist of:
        </p>

        <ul>
          <li>
Information related to identifying the [=subject=] of the [=credential=]
(for example, a photo, name, or identification number)
          </li>
          <li>
Information related to the issuing authority (for example, a city government,
national agency, or certification body)
          </li>
          <li>
Information related to the type of [=credential=] this is (for example, a
Dutch passport, an American driving license, or a health insurance card)
          </li>
          <li>
Information related to specific attributes or properties being asserted by
the issuing authority about the [=subject=] (for example, nationality,
the classes of vehicle entitled to drive, or date of birth)
          </li>
          <li>
Evidence related to how the [=credential=] was derived
          </li>
          <li>
Information related to constraints on the credential (for example,
validity period, or terms of use).
          </li>
        </ul>

        <p>
A [=verifiable credential=] can represent all of the same information that a
physical [=credential=] represents. The addition of technologies, such as
digital signatures, makes [=verifiable credentials=] more tamper-evident and
more trustworthy than their physical counterparts.
        </p>

        <p>
[=Holders=] of [=verifiable credentials=] can generate
[=verifiable presentations=] and then share these
[=verifiable presentations=] with [=verifiers=] to prove they possess
[=verifiable credentials=] with certain characteristics.
        </p>

        <p>
Both [=verifiable credentials=] and [=verifiable presentations=] can be
transmitted rapidly, making them more convenient than their physical
counterparts when trying to establish trust at a distance.
        </p>

        <p>
While this specification attempts to improve the ease of expressing digital
[=credentials=], it also attempts to balance this goal with a number of
privacy-preserving goals. The persistence of digital information, and the ease
with which disparate sources of digital data can be collected and correlated,
comprise a privacy concern that the use of [=verifiable=] and easily
machine-readable [=credentials=] threatens to make worse. This document
outlines and attempts to address a number of these issues in Section
<a href="#privacy-considerations"></a>. Examples of how to use this data model
using privacy-enhancing technologies, such as zero-knowledge proofs, are also
provided throughout this document.
        </p>

        <p>
The word "verifiable" in the terms
[=verifiable credential=] and [=verifiable presentation=]
refers to the characteristic of a [=credential=] or [=presentation=]
as being able to be [=verified=] by a [=verifier=],
as defined in this document. Verifiability of a credential does not imply
the truth of [=claims=] encoded therein. Rather, once the authenticity and
currency of a [=verifiable credential=] or [=verifiable presentation=] are
established, a [=verifier=] validates the included claims using their own
business rules before relying on them. Such reliance only occurs after
evaluating the issuer, the proof, the subject, and the claims, against one or
more verifier policies.
        </p>
      </section>

      <section class="informative">
        <h3>Ecosystem Overview</h3>

        <p>
This section describes the roles of the core actors and the relationships
between them in an ecosystem where [=verifiable credentials=] are expected
to be useful. A role is an abstraction that might be implemented in many
different ways. The separation of roles suggests likely interfaces and
protocols for standardization. The following roles are introduced in this
specification:
        </p>

        <dl>
          <dt>[=holder=]</dt>
          <dd>
A role an [=entity=] might perform by possessing one or more
[=verifiable credentials=] and generating [=verifiable presentations=]
from them. Example holders include students, employees, and customers.
          </dd>
          <dt>[=issuer=]</dt>
          <dd>
A role an [=entity=] performs by asserting [=claims=] about one or
more [=subjects=], creating a [=verifiable credential=] from these
[=claims=], and transmitting the [=verifiable credential=] to a
[=holder=]. Example issuers include corporations, non-profit organizations,
trade associations, governments, and individuals.
          </dd>
          <dt>[=subject=]</dt>
          <dd>
An [=entity=] about which [=claims=] are made. Example subjects include
human beings, animals, and things. In many cases the [=holder=] of a
[=verifiable credential=] is the subject, but in certain cases it is not. For
example, a parent (the [=holder=]) might hold the
[=verifiable credentials=] of a child (the [=subject=]), or a pet owner
(the [=holder=]) might hold the [=verifiable credentials=] of their pet
(the [=subject=]). For more information about these special cases, see the
<a href="https://www.w3.org/TR/vc-imp-guide/#subject-holder-relationships">
Subject-Holder Relationships</a> section in the Verifiable Credentials
Implementation Guide [[VC-IMP-GUIDE]].
          </dd>
          <dt>[=verifier=]</dt>
          <dd>
A role an [=entity=] performs by receiving one or more
[=verifiable credentials=], optionally inside a
[=verifiable presentation=], for processing. Example verifiers include
employers, security personnel, and websites.
          </dd>
          <dt>[=verifiable data registry=]</dt>
          <dd>
A role a system might perform by mediating the creation and [=verification=]
of identifiers, keys, and other relevant data, such as
[=verifiable credential=] schemas, revocation registries, issuer public keys,
and so on, which might be required to use [=verifiable credentials=]. Some
configurations might require correlatable identifiers for [=subjects=].
Example verifiable data registries include trusted databases, decentralized
databases, government ID databases, and distributed ledgers. Often
there is more than one type of verifiable data registry utilized in an
ecosystem.
          </dd>
        </dl>

        <figure id="roles">
          <img style="margin: auto; display: block; width: 75%;"
               src="diagrams/ecosystem.svg" alt="diagram showing how
               credentials flow from issuer to holder and
               presentations flow from holder to verifier where all
               three parties can use information from a logical
               verifiable data registry">
          <figcaption style="text-align: center;">
            The roles and information flows forming the basis for this specification.
          </figcaption>
        </figure>

        <p class="note">
<a href="#roles"></a> above provides an example ecosystem in which to ground the
rest of the concepts in this specification. Other ecosystems exist, such as
protected environments or proprietary systems, where
[=verifiable credentials=] also provide benefit.
        </p>
      </section>

      <section class="informative">
        <h3>Use Cases and Requirements</h3>

        <p>
The Verifiable Credentials Use Cases document [[VC-USE-CASES]] outlines a number
of key topics that readers might find useful, including:
        </p>

        <ul>
          <li>
A more thorough explanation of the
<a href="https://www.w3.org/TR/vc-use-cases/#user-roles">roles</a>
introduced above
          </li>
          <li>
The
<a href="https://www.w3.org/TR/vc-use-cases/#user-needs">needs</a>
identified in market verticals, such as education, finance, healthcare, retail,
professional licensing, and government
          </li>
          <li>
Common
<a href="https://www.w3.org/TR/vc-use-cases/#user-tasks">tasks</a>
performed by the roles in the ecosystem, as well as their associated
requirements
          </li>
          <li>
Common
<a href="https://www.w3.org/TR/vc-use-cases/#user-sequences">sequences
and flows</a> identified by the Working Group.
          </li>
        </ul>

        <p>
As a result of documenting and analyzing the use cases document, the following
desirable ecosystem characteristics were identified for this specification:
        </p>
<!-- requirement list start -->
        <ul>
          <li>
[=Verifiable credentials=] represent statements made by an [=issuer=] in
a tamper-evident and privacy-respecting manner.
          </li>
          <li>
[=Holders=] can assemble collections of [=verifiable credentials=] from
different [=issuers=] into a single artifact, a [=verifiable presentation=].
          </li>
          <li>
[=Issuers=] can issue [=verifiable credentials=] about any [=subject=].
          </li>
          <li>
Acting as [=issuer=], [=holder=], or [=verifier=] requires neither
registration nor approval by any authority, as the trust involved is bilateral
between parties.
          </li>
          <li>
[=Verifiable presentations=] allow any [=verifier=] to [=verify=] the
authenticity of [=verifiable credentials=] from any [=issuer=].
          </li>
          <li>
[=Holders=] can receive [=verifiable credentials=] from anyone.
          </li>
          <li>
[=Holders=] can interact with any [=issuer=] and any [=verifier=]
through any user agent.
          </li>
          <li>
[=Holders=] can share [=verifiable presentations=], which can then be
[=verified=] without revealing the identity of the [=verifier=] to the
[=issuer=].
          </li>
          <li>
[=Holders=] can store [=verifiable credentials=] in any location, without
affecting their [=verifiability=] and without the [=issuer=] knowing
anything about where they are stored or when they are accessed.
          </li>
          <li>
[=Holders=] can present [=verifiable presentations=] to any
[=verifier=] without affecting authenticity of the claims and without
revealing that action to the [=issuer=].
          </li>
          <li>
A [=verifier=] can [=verify=] [=verifiable presentations=] from any
[=holder=], containing proofs of [=claims=] from any [=issuer=].
          </li>
          <li>
[=Verification=] should not depend on direct interactions between
[=issuers=] and [=verifiers=].
          </li>
          <li>
[=Verification=] should not reveal the identity of the [=verifier=] to
any [=issuer=].
          </li>
          <li>
The specification must provide a means for [=issuers=] to issue
[=verifiable credentials=] that support selective disclosure, without
requiring all conformant software to support that feature.
          </li>
          <li>
[=Issuers=] can issue [=verifiable credentials=] that support
selective disclosure.
          </li>
          <li>
If a single [=verifiable credential=] supports selective disclosure, then
[=holders=] can present proofs of [=claims=] without revealing the entire
[=verifiable credential=].
          </li>
          <li>
[=Verifiable presentations=] can either disclose the attributes of a
[=verifiable credential=], or satisfy [=derived predicates=] requested by
the [=verifier=]. [=Derived predicates=] are Boolean conditions, such as
greater than, less than, equal to, is in set, and so on.
          </li>
          <li>
[=Issuers=] can issue revocable [=verifiable credentials=].
          </li>
          <li>
The processes of cryptographically protecting and verifying
[=verifiable credentials=] and [=verifiable presentations=] have to be
deterministic, bi-directional, and lossless. Any
[=verifiable credential=] or [=verifiable presentation=] has to be
transformable to the JSON-LD data model defined in this document via a
deterministic process so that its verification can be processed in an
interoperable fashion.
          </li>
          <li>
[=Verifiable credentials=] and [=verifiable presentations=] have to be
serializable in one or more machine-readable data formats. The process of
serialization and/or de-serialization has to be deterministic, bi-directional,
and lossless. Any serialization of a [=verifiable credential=] or
[=verifiable presentation=] needs to be transformable to the generic data
model defined in this document in a deterministic process such that the
resulting [=verifiable credential=] can be processed in an interoperable
fashion. The serialized form also needs to be able to be generated from the data
model without loss of data or content.
          </li>
          <li>
The data model and serialization must be extendable with minimal coordination.
          </li>
          <li>
Revocation by the [=issuer=] should not reveal any identifying information
about the [=subject=], the [=holder=], the specific
[=verifiable credential=], or the [=verifier=].
          </li>
          <li>
[=Issuers=] can disclose the revocation reason.
          </li>
          <li>
[=Issuers=] revoking [=verifiable credentials=] should distinguish between
revocation for cryptographic integrity (for example, the signing key is
compromised) versus revocation for a status change (for example, the driver's
license is suspended).
          </li>
          <li>
[=Issuers=] can provide a service for refreshing a
[=verifiable credential=].
          </li>
        </ul>
      </section>

      <section id="conformance" class="normative">
        <p>
A <dfn>conforming document</dfn> is a
<a data-cite="JSON-LD11-API#compaction-algorithms">compacted</a> JSON-LD
document that complies with all of the relevant "MUST" statements in this
specification. Specifically, the relevant normative "MUST" statements in
Sections <a href="#basic-concepts"></a>, <a href="#advanced-concepts"></a>, and
<a href="#syntaxes"></a> of this document MUST be enforced.
A conforming document is either a [=verifiable credential=] that MUST be
serialized using the `application/vc+ld+json` media type or a
[=verifiable presentation=] that MUST be serialized using the
`application/vp+ld+json` media type. A conforming document MUST be
secured by at least one securing mechanism as described in Section
<a href="#securing-mechanisms"></a>.
        </p>

        <p>
A <dfn class="lint-ignore">conforming issuer implementation</dfn> produces
[=conforming documents=], MUST include all required properties in the
[=conforming documents=] that it produces, and MUST secure the <a>conforming
documents</a> it produces using a securing mechanism as described in Section
<a href="#securing-mechanisms"></a>.
        </p>

        <p>
A <dfn class="lint-ignore">conforming verifier implementation</dfn>
consumes [=conforming documents=], MUST perform [=verification=] on a
[=conforming document=] as described in Section
<a href="#securing-mechanisms"></a>, MUST check that each
required property satisfies the normative requirements for that property, and
MUST produce errors when non-[=conforming documents=] are detected.
        </p>

        <p>
This specification includes both required and optional properties. Optional
properties MAY be ignored by [=conforming issuer implementations=] and/or
[=conforming verifier implementations=].
        </p>

        <p>
This document also contains examples that contain characters that are invalid
JSON, such as inline comments (`//`) and the use of ellipsis
(`...`) to denote information that adds little value to the example.
Implementers are cautioned to remove this content if they desire to use the
information as a valid document.
        </p>
      </section>

    </section>

    <section class="normative">
      <h2>Terminology</h2>

      <div data-include="./terms.html"></div>
    </section>

    <section class="informative">
      <h2>Core Data Model</h2>

      <p>
The following sections outline core data model concepts, such as [=claims=],
[=credentials=], [=presentations=], [=verifiable credentials=], and
[=verifiable presentations=], which form the foundation of this
specification.
      </p>

      <p class="note"
        title="The difference between a credential and a verifiable credential">
Readers might note that some concepts described in this section, such as
[=credential=] and [=presentation=], do not have media types defined by
this specification. However, the concepts of a [=verifiable credential=] or a
[=verifiable presentation=] are defined as [=conforming documents=] and do
have associated media types. The concrete difference between these concepts
&mdash; between [=credential=] and [=presentation=] vs. <a>verifiable
credential</a> and [=verifiable presentation=] &mdash; is simply the fact
that the "verifiable" objects are secured in a way that is cryptographically
verifiable, and the others are not. For more details, see Section
<a href="#securing-mechanisms"></a>.
      </p>

      <section class="informative">
        <h3>Claims</h3>

        <p>
A [=claim=] is a statement about a [=subject=]. A [=subject=] is a
thing about which [=claims=] can be made. [=Claims=] are expressed using
<strong><em>subject</em></strong>-<dfn data-lt="property|properties">
property</dfn>-<dfn class="lint-ignore">value</dfn> relationships.
        </p>

        <figure id="basic-structure">
          <img style="margin: auto; display: block; width: 50%;"
            src="diagrams/claim.svg" alt="subject has a property which
            has a value">
          <figcaption style="text-align: center;">
The basic structure of a claim.
          </figcaption>
        </figure>

        <p>
The data model for [=claims=], illustrated in <a href="#basic-structure"></a>
above, is powerful and can be used to express a large variety of statements. For
example, whether someone graduated from a particular university can be expressed
as shown in <a href="#basic-example"></a> below.
        </p>

        <figure id="basic-example">
          <img style="margin: auto; display: block; width: 60%;"
            src="diagrams/claim-example.svg" alt="Pat has an alumniOf
            property whose value is Example University">
          <figcaption style="text-align: center;">
A basic claim expressing that Pat is an alumni of "Example University".
          </figcaption>
        </figure>

        <p>
Individual [=claims=] can be merged together to express a [=graph=] of
information about a [=subject=]. The example shown in
<a href="#multiple-claims"></a> below extends the previous [=claim=] by
adding the [=claims=] that Pat knows Sam and that Sam is employed as a
professor.
        </p>

        <figure id="multiple-claims">
          <img style="margin: auto; display: block; width: 75%;"
            src="diagrams/claim-extended.svg" alt="extends previous
            diagram with another property called knows whose value is
            Sam, and Sam has a property jobTitle whose value is Professor">
          <figcaption style="text-align: center;">
Multiple claims can be combined to express a graph of information.
          </figcaption>
        </figure>

        <p>
To this point, the concepts of a [=claim=] and a [=graph=] of information
are introduced. To be able to trust [=claims=], more information is
expected to be added to the graph.
        </p>
      </section>

      <section class="informative">
        <h3>Credentials</h3>

        <p>
A [=credential=] is a set of one or more [=claims=] made by the same
[=entity=]. [=Credentials=] might also include an identifier and metadata
to describe properties of the [=credential=], such as the
[=issuer=], the validity date and time period, a representative image, a
public key to use for [=verification=] purposes, the revocation mechanism,
and so on. The metadata might be signed by the [=issuer=]. A
[=verifiable credential=] is a set of tamper-evident [=claims=] and
metadata that cryptographically prove who issued it.
        </p>

        <figure id="basic-vc">
          <img style="margin: auto; display: block; width: 50%;"
               src="diagrams/vc.svg" alt="a Verifiable
               Credential contains Credential Metadata, Claim(s), and
               Proof(s)">
          <figcaption style="text-align: center;">
Basic components of a verifiable credential.
          </figcaption>
        </figure>

        <p>
Examples of [=verifiable credentials=] include digital employee
identification cards, digital birth certificates, and digital educational
certificates.
        </p>

        <p class="note">
[=Credential=] identifiers are often used to identify specific instances
of a [=credential=]. These identifiers can also be used for correlation. A
[=holder=] wanting to minimize correlation is advised to use a selective
disclosure scheme that does not reveal the [=credential=] identifier.
        </p>

        <p>
<a href="#basic-vc"></a> above shows the basic components of a
[=verifiable credential=], but abstracts the details about how [=claims=]
are organized into information [=graphs=], which are then organized into
[=verifiable credentials=]. <a href="#info-graph-vc"></a> below shows a
more complete depiction of a [=verifiable credential=], which is normally
composed of at least two information [=graphs=]. The first [=graph=]
(the [=verifiable credential graph=], in this case the [=default graph=])
expresses the [=verifiable credential=] itself, which contains credential
metadata and other [=claims=]. The second [=graph=]
(the [=proof graph=] of the [=verifiable credential=], which is a <a>named
graph</a>) expresses the digital proof, which is, in this case, a digital
signature.
        </p>

        <figure id="info-graph-vc">
        <img style="margin: auto; display: block; width: 100%;"
             src="diagrams/vc-graph.svg" alt="Diagram with a collections of
claims for a 'verifiable credential graph' on top
connected via a proof property (or predicate) to a 'verifiable credential proof
graph' on the bottom. The claims for a verifiable credential include 'Credential
123' as a subject with 4 properties: 'type' of value ExampleAlumniCredential,
'issuer' of Example University, 'validFrom' of 2010-01-01T19:23:24Z, and
credentialSubject of Pat, who also has an alumniOf property with value of
Example University.  The verifiable credential proof graph has an object
'Signature 456' subject with 5 properties: 'type' of DataIntegrityProof,
'verificationMethod' of Example University Public Key 7, 'created' of
2017-06-18T21:19:10Z, a 'nonce' of 34dj239dsj328, and 'proofValue' of
'zBavE110…3JT2pq'. The verifiable credential graph is also annotated with the
parenthetical remark '(the default graph)', the verifiable credential proof
graph is annotated with the parenthetical remark '(a named graph)'.">
          <figcaption style="text-align: center;">
Information graphs associated with a basic verifiable credential.
          </figcaption>
        </figure>

        <p class="note">
It is possible to have a [=credential=], such as a marriage certificate,
containing multiple [=claims=] about different [=subjects=] that are not
required to be related.
        </p>
        <p class="note">
It is possible to have a [=credential=] that does not contain any
[=claims=] about the [=entity=] to which the [=credential=] was issued.
For example, a [=credential=] that only contains [=claims=] about a
specific dog, but is issued to its owner.
        </p>
      </section>

      <section class="informative">
        <h3>Presentations</h3>

        <p>
Enhancing privacy is a key design feature of this specification. Therefore, it
is important for [=entities=] using this technology to be able to express
only the portions of their persona that are appropriate for a given situation.
The expression of a subset of one's persona is called a
[=verifiable presentation=]. Examples of different personas include a
person's professional persona, their online gaming persona, their
family persona, or an incognito persona.
        </p>

        <p>
A [=verifiable presentation=] can express data from multiple
[=verifiable credentials=] and contain arbitrary additional data encoded as
JSON-LD. They are used by a [=holder=] to present [=claims=] to a
[=verifier=]. It is also possible to present [=verifiable credentials=]
directly.
        </p>

        <p>
The data in a [=presentation=] is often about the same [=subject=], but
might have been issued by multiple [=issuers=]. The aggregation of this
information typically expresses an aspect of a person, organization, or
[=entity=].
        </p>

        <figure id="basic-vp">
          <img style="margin: auto; display: block; width: 50%;"
            src="diagrams/presentation.svg" alt="A Verifiable
            Presentation contains Presentation Metadata, Verifiable
            Credential(s), and Proof(s)">
          <figcaption style="text-align: center;">
Basic components of a verifiable presentation.
          </figcaption>
        </figure>

        <p>
<a href="#basic-vp"></a> above shows the components of a
[=verifiable presentation=], but abstracts the details about how
[=verifiable credentials=] are organized into information [=graphs=],
which are then organized into [=verifiable presentations=].
        </p>
        <p>
<a href="#info-graph-vp"></a> below shows a more complete depiction of a
[=verifiable presentation=], which is normally composed of at least four
information [=graphs=]. The first of these [=graphs=], the
[=verifiable presentation graph=] (which is the [=default graph=]),
expresses the [=verifiable presentation=] itself, and contains presentation
metadata. The `verifiableCredential` property in the <a>verifiable
presentation graph</a> refers to one or more [=verifiable credentials=], each
being one of the second information [=graphs=], i.e., a self-contained
[=verifiable credential graph=] which in turn contains credential metadata
and other claims. Each of these graphs are separate [=named graphs=]. The
third information [=graph=], the verifiable credential [=proof graph=],
expresses the credential graph proof, which is usually a digital signature. The
fourth information [=named graph=], the presentation [=proof graph=],
expresses the presentation's digital proof, which is usually a digital
signature.
        </p>

        <figure id="info-graph-vp">
        <img style="margin: auto; display: block; width: 100%;"
               src="diagrams/vp-graph.svg" alt="Diagram with a
'verifiable presentation graph' on top connected via a 'proof' to
a 'verifiable presentation proof graph on the bottom.  The verifiable
presentation graph has and object 'Presentation ABC' with 3 properties: 'type'
of value VerifiablePresentation, 'termsOfUse' of value 'Do Not Archive'. The
graph is annotated with the parenthetical remark '(the default graph)'. This
graph is connected, through 'verifiableCredential', to the part of the figure
which is identical to Figure 6, except that the verifiable credential graph is
annotated to be a named graph instead of a default graph.
The verifiable presentation proof graph, has and object with 'Signature 8910'
with 5 properties: 'type' of DataIntegrityProof, 'verificationMethod' of Example
Presenter Public Key 11, 'created' of 2018-01-15T12:43:56Z, 'challenge' of
d28348djsj3239, a 'nonce' of 'd28348djsj3239', and 'proofValue' of
'p2KaZ...8Fj3K='. This graph is annotated with the parenthetical remark '(a
named graph)'">
          <figcaption style="text-align: center;">
Information graphs associated with a basic verifiable presentation.
          </figcaption>
        </figure>

        <p class="note">
It is possible to have a [=presentation=], such as a business persona, which
draws on multiple [=credentials=] about different [=subjects=] that are
often, but not required to be, related.
        </p>

      </section>

      <section class="informative">
        <h3>Concrete Lifecycle Example</h3>

        <p>
The previous sections introduced the concepts of [=claims=],
[=verifiable credentials=], and [=verifiable presentations=] using
graphical depictions. This section provides a concrete set of simple but
complete lifecycle examples of the data model expressed in one of the concrete
syntaxes supported by this specification. The lifecycle of [=credentials=]
and [=presentations=] in the
<a href="#ecosystem-overview">Verifiable Credentials Ecosystem</a> often
take a common path:
        </p>

        <ol>
          <li>
Issuance of one or more [=verifiable credentials=].
          </li>
          <li>
Storage of [=verifiable credentials=] in a [=credential repository=]
(such as a digital wallet).
          </li>
          <li>
Composition of [=verifiable credentials=] into a
[=verifiable presentation=] for [=verifiers=].
          </li>
          <li>
[=Verification=] of the [=verifiable presentation=] by the
[=verifier=].
          </li>
          <li>
[=Validation=] by the [=verifier=] of relevant [=claims=] contained in
the [=verifiable presentation=].
          </li>
        </ol>

        <p>
To illustrate this lifecycle, we will use the example of redeeming an alumni
discount from a university. In the example below, Pat receives an alumni
[=verifiable credential=] from a university, and Pat stores the
[=verifiable credential=] in a digital wallet.
        </p>

        <pre class="example nohighlight" title="A simple example of the contents of a verifiable credential">
{
  <span class='comment'>// set the context, which establishes the special terms we will be using
  // such as 'issuer' and 'alumniOf'.</span>
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  <span class='comment'>// specify the identifier for the credential</span>
  "id": "http://university.example/credentials/1872",
  <span class='comment'>// the credential types, which declare what data to expect in the credential</span>
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  <span class='comment'>// the entity that issued the credential</span>
  "issuer": "https://university.example/issuers/565049",
  <span class='comment'>// when the credential was issued</span>
  "validFrom": "2010-01-01T19:23:24Z",
  <span class='comment'>// claims about the subjects of the credential</span>
  "credentialSubject": {
    <span class='comment'>// identifier for the only subject of the credential</span>
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    <span class='comment'>// assertion about the only subject of the credential</span>
    "alumniOf": {
      <span class='comment'>// identifier for the university</span>
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      <span class='comment'>// name of the university</span>
      "name": "Example University"
    }
  }
}
        </pre>

        <p>
Pat then attempts to redeem the alumni discount. The [=verifier=], a ticket
sales system, states that alumni of "Example University" receive a discount
on season tickets to sporting events. Using a mobile device, Pat starts the
process of purchasing a season ticket. A step in this process requests an alumni
[=verifiable credential=], and this request is routed to Pat's digital wallet.
The digital wallet asks Pat if they would like to provide a previously issued
[=verifiable credential=]. Pat selects the alumni
[=verifiable credential=], which is then composed into a
[=verifiable presentation=]. The [=verifiable presentation=] is sent to
the [=verifier=] and [=verified=].
        </p>
        <p>
Once [=verified=] as authentic and current, the seller of the season ticket then
validates that the [=issuer=] of the [=verifiable credential=] is recognized for
the claim of alumni status &mdash; it is, as it was issued by Example
University &mdash; and that today's date lies within the validity period defined
by the values of the `validFrom` and `validUntil` properties. Since the [=holder=] is
expected to be the [=subject=] of the [=verifiable credential=], the
[=verifier=] also confirms that the `id` for the alumni claim matches the `id` of
the creator of the [=verifiable presentation=].
        </p>
        <p>
Having [=verified=] the credential and the presentation, and validated the
relevant claims, the ticket seller safely enables the alumni discount for Pat,
confident that Pat is legitimately entitled to it.
        </p>
        <pre class="example nohighlight" title="A simple example of a verifiable presentation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": "VerifiablePresentation",
  <span class='comment'>// the verifiable credential issued in the previous example</span>
  "verifiableCredential": [{
    "@context": [
      "https://www.w3.org/ns/credentials/v2",
      "https://www.w3.org/ns/credentials/examples/v2"
    ],
    "id": "http://university.example/credentials/1872",
    "type": ["VerifiableCredential", "ExampleAlumniCredential"],
    "issuer": "https://university.example/issuers/565049",
    "validFrom": "2010-01-01T19:23:24Z",
    "credentialSubject": {
      "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "alumniOf": {
        "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
        "name": "Example University"
      }
    }
  }]
}
        </pre>

        <p class="note">
The examples above are unsecured. Implementers that are interested in
understanding more about securing [=verifiable credentials=] can see the
specifications [[[VC-JOSE-COSE]]]
[[VC-JOSE-COSE]] and [[[VC-DATA-INTEGRITY]]] [[VC-DATA-INTEGRITY]]
and the "Proofs" section of the [[[VC-SPECS]]]
[[VC-SPECS]].
        </p>
      </section>
    </section>

    <section class="normative">
      <h2>Basic Concepts</h2>

      <p>
This section introduces some basic concepts for the specification, in
preparation for Section <a href="#advanced-concepts"></a> later in the
document.
      </p>

      <section class="informative">
        <h3>Getting Started</h3>

        <p>
This specification is designed to ease the prototyping of new types of
[=verifiable credentials=]. Developers can copy the
template below and paste it into common [=verifiable credential=]
tooling to start issuing, holding, and verifying prototype credentials.
        </p>

        <p>
It is expected that a developer will change `MyPrototypeCredential` below to
the type of credential they would like to create. Since
[=verifiable credentials=] talk about subjects, each property-value pair in
the `credentialSubject` object expresses a particular attribute of the
credential subject. Once a developer has added a number of these property-value
combinations, the modified object can be sent to [=verifiable credential=]
issuer software and a [=verifiable credential=] will be created for the
developer. From a prototyping standpoint, that is all a developer needs to do.
        </p>

        <pre class="example nohighlight" title="A template for creating prototype verifiable credentials">
{
  "@context": ["https://www.w3.org/ns/credentials/v2"],
  "type": ["VerifiableCredential", "MyPrototypeCredential"],
  "credentialSubject": {
    "mySubjectProperty": "mySubjectValue"
  }
}
        </pre>

        <p>
Once a developer has prototyped their credential to a point where they believe
all of the credential properties are stable, it is advised that they generate
vocabulary and context files for their application and publish them at stable URLs
so that other developers can use the same vocabulary and context to achieve
interoperability. This process is covered in Section
<a href="#extensibility"></a>. Alternatively, developers can reuse existing vocabulary
and context files that happen to fit their use case. They can explore the
[[[VC-SPECS]]] [[VC-SPECS]] for reusable resources.
        </p>

      </section>

      <section>
        <h3>Contexts</h3>

        <p>
When two software systems need to exchange data, they need to use terminology
that both systems understand. As an analogy, consider how two people
communicate. Both people must use the same language and the words they use must
mean the same thing to each other. This might be referred to as
<em>the context of a conversation</em>.
        </p>
        <p>
[=Verifiable credentials=] and [=verifiable presentations=] have many
attributes and values that are identified by [=URLs=] [[URL]]. However,
those [=URLs=] can be long and not very human-friendly. In such cases,
short-form human-friendly aliases can be more helpful. This specification uses
the `@context` [=property=] to map such short-form aliases to the
[=URLs=] required by specific [=verifiable credentials=] and <a>verifiable
presentations</a>.
       </p>
  <p class="note">
In JSON-LD, the `@context` [=property=] can also be used to
communicate other details, such as datatype information, language information,
transformation rules, and so on, which are beyond the needs of this
specification, but might be useful in the future or to related work. For more
information, see
<a href="https://www.w3.org/TR/json-ld11/#the-context">Section 3.1: The Context</a>
of the [[[JSON-LD]]] [[JSON-LD]] specification.
        </p>
        <p>
[=Verifiable credentials=] and [=verifiable presentations=] MUST include a
`@context` [=property=].
        </p>

        <dl>
          <dt><dfn class="export">@context</dfn></dt>
          <dd>
The value of the `@context` [=property=] MUST be an ordered set
where the first item is a [=URL=] with the value
`https://www.w3.org/ns/credentials/v2`. For reference, a copy of
the base context is provided in Appendix <a href="#base-context"></a>.
Subsequent items in the array MUST be composed of any combination of
[=URLs=] and/or objects where each is processable as a
<a data-cite="JSON-LD11#the-context">JSON-LD Context</a>.
          </dd>
        </dl>
        <p class="note">
This specification requires for a `@context` [=property=]
to be present; this property is defined by [[JSON-LD]].
        </p>
        <pre class="example nohighlight" title="Usage of the @context property">
{
  <span class="highlight">"@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ]</span>,
  "id": "http://university.example/credentials/58473",
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": "Example University"
    }
  }
}
        </pre>

        <p>
The example above uses the base context [=URL=]
(`https://www.w3.org/ns/credentials/v2`) to establish that the
conversation is about a [=verifiable credential=]. The second [=URL=]
(`https://www.w3.org/ns/credentials/examples/v2`) establishes that
the conversation is about examples.
        </p>

        <p class="note">
This document uses the example context [=URL=]
(`https://www.w3.org/ns/credentials/examples/v2`) for the purpose
of demonstrating examples. Implementations are expected to not use this
[=URL=] for any other purpose, such as in pilot or production systems.
        </p>

        <p>
The data available at `https://www.w3.org/ns/credentials/v2` is a
static document that is never updated and SHOULD be downloaded and cached. The
associated human-readable vocabulary document for the Verifiable Credentials
Data Model is available at
<a href="https://www.w3.org/2018/credentials/">https://www.w3.org/2018/credentials/</a>.
This concept is further expanded on in Section <a href="#extensibility"></a>.
        </p>

      </section>

      <section>
        <h3>Identifiers</h3>

        <p>
When expressing statements about a specific thing, such as a person, product, or
organization, it can be useful to use a globally unique identifier for that thing.
Globally unique identifiers enable others to express statements
about the same thing. This specification defines the optional `id`
[=property=] for such identifiers. The `id` [=property=]
allows for the expression of statements about specific things in the
[=verifiable credential=] and is set by an [=issuer=] when expressing
objects in a [=verifiable credential=] or a [=holder=] when expressing
objects in a [=verifiable presentation=]. Example `id` values
include UUIDs (`urn:uuid:0c07c1ce-57cb-41af-bef2-1b932b986873`), HTTP URLs
(`https://id.example/things#123`), and DIDs (`did:example:1234abcd`).
        </p>

        <p>
<em>If</em> the `id` [=property=] is present:
        </p>

        <ul>
          <li>
The `id` [=property=] MUST express an identifier that others are
expected to use when expressing statements about a specific thing identified
by that identifier.
          </li>
          <li>
The `id` [=property=] MUST NOT have more than one value.
          </li>
          <li>
The value of the `id` [=property=] MUST be a [=URL=] which
MAY be dereferenced.
          </li>
        </ul>

        <p class="note">
Developers should remember that identifiers might be harmful in scenarios
where pseudonymity is required. Developers are encouraged to read Section
<a href="#identifier-based-correlation"></a> carefully when considering such
scenarios. There are also other types of correlation mechanisms documented in
Section <a href="#privacy-considerations"></a> that create privacy concerns.
Where privacy is a strong consideration, the `id` [=property=]
MAY be omitted. Some use cases do not require, or explicitly require omitting,
the `id` [=property=].
        </p>

        <dl>
          <dt><dfn class="export">id</dfn></dt>
          <dd>
The value of the `id` [=property=] MUST be a single [=URL=].
It is RECOMMENDED that the [=URL=] in the `id` be one which, if
dereferenced, results in a document containing machine-readable information
about the `id`.
          </dd>
        </dl>

        <pre class="example nohighlight vc" title="Usage of the id property"
          data-vc-vm="https://university.example/issuers/565049#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  <span class="highlight">"id": "http://university.example/credentials/3732"</span>,
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    <span class="highlight">"id": "did:example:ebfeb1f712ebc6f1c276e12ec21"</span>,
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <p>
The example above uses two types of identifiers. The first identifier is for
the [=verifiable credential=] and uses an HTTP-based URL. The second
identifier is for the [=subject=] of the [=verifiable credential=] (the
thing the [=claims=] are about) and uses a [=decentralized identifier=],
also known as a [=DID=].
        </p>

        <p class="note">
As of this publication, [=DIDs=] are a new type of identifier that are not
necessary for [=verifiable credentials=] to be useful. Specifically,
[=verifiable credentials=] do not depend on [=DIDs=] and [=DIDs=] do
not depend on [=verifiable credentials=]. However, it is expected that many
[=verifiable credentials=] will use [=DIDs=] and that software libraries
implementing this specification will probably need to resolve [=DIDs=].
[=DID=]-based URLs are used for expressing identifiers associated with
[=subjects=], [=issuers=], [=holders=], credential status lists,
cryptographic keys, and other machine-readable information associated with a
[=verifiable credential=].
        </p>
      </section>

      <section>
        <h3>Types</h3>

        <p>
Software systems that process the kinds of objects specified in this document
use type information to determine whether or not a provided
[=verifiable credential=] or [=verifiable presentation=] is appropriate
for the intended use case. This specification defines a `type`
[=property=] for the expression of type information. This type information
can be used during [=validation=] processes as described in Appendix
<a href="#validation"></a>.
        </p>

        <p>
[=Verifiable credentials=] and [=verifiable presentations=] MUST have a
`type` [=property=]. That is, any [=credential=] or
[=presentation=] that does not have `type` [=property=]
<em>is not [=verifiable=]</em>, so is neither a [=verifiable credential=]
nor a [=verifiable presentation=].
        </p>

        <dl>
          <dt><dfn class="export" data-lt="type|types">type</dfn></dt>
          <dd>
The value of the `type` [=property=] MUST be, or map to (through
interpretation of the `@context` property), one or more [=URLs=].
If more than one [=URL=] is provided, the [=URLs=] MUST be interpreted
as an unordered set. Syntactic conveniences SHOULD be used to ease developer
usage. Such conveniences might include JSON-LD terms. It is RECOMMENDED that
each [=URL=] in the `type` be one which, if dereferenced, results
in a document containing machine-readable information about the
`type`.
          </dd>
        </dl>

        <pre class="example nohighlight vc" title="Usage of the type property"
          data-vc-vm="https://university.example/issuers/565049#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  <span class="highlight">"type": ["VerifiableCredential", "ExampleDegreeCredential"]</span>,
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <p>
With respect to this specification, the following table lists the objects that
MUST have a [=type=] specified.
        </p>

        <table class="simple">
          <thead>
            <tr>
              <th>Object</th>
              <th>Type</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>
[=Verifiable credential=]&nbsp;object
              </td>
              <td>
`VerifiableCredential` and, optionally, a more specific
[=verifiable credential=] [=type=]. For example,<br>
`"type": ["VerifiableCredential", "ExampleDegreeCredential"]`
              </td>
            </tr>

            <tr>
              <td>
[=Verifiable presentation=]&nbsp;object
              </td>
              <td>
`VerifiablePresentation` and, optionally, a more specific
[=verifiable presentation=] [=type=]. For example,<br>
`"type": ["VerifiablePresentation", "ExamplePresentation"]`
              </td>
            </tr>

            <tr>
              <td>
<a href="#proofs-signatures">Proof</a>&nbsp;object
              </td>
              <td>
A valid proof [=type=]. For example,<br>
`"type": "DataIntegrityProof"`
              </td>
            </tr>

            <tr>
              <td>
<a href="#status">credentialStatus</a>&nbsp;object
              </td>
              <td>
A valid [=credential=] status [=type=]. For example,<br>
`"type": "StatusList2021Entry"`
              </td>
            </tr>

            <tr>
              <td>
<a href="#terms-of-use">termsOfUse</a>&nbsp;object
              </td>
              <td>
A valid terms of use [=type=]. For example,<br>
`"type": "ExampleTermsPolicy"`)
              </td>
            </tr>

            <tr>
              <td>
<a href="#evidence">evidence</a>&nbsp;object
              </td>
              <td>
A valid evidence [=type=]. For example,<br>
`"type": "ExampleEvidence"`
              </td>
            </tr>

          </tbody>
        </table>

        <p class="note">
The [=type=] system for the Verifiable Credentials Data Model is the same as
for [[JSON-LD]] and is detailed in
<a href="https://www.w3.org/TR/json-ld/#specifying-the-type">Section 3.5:
Specifying the Type</a> and
<a href="https://www.w3.org/TR/json-ld/#json-ld-grammar">Section 9: JSON-LD
Grammar</a>. When using a JSON-LD context (see Section
<a href="#extensibility"></a>), this specification aliases the
`@type` keyword to `type` to make the JSON-LD documents
more easily understood. While application developers and document authors do
not need to understand the specifics of the JSON-LD type system, implementers
of this specification who want to support interoperable extensibility, do.
        </p>

        <p>
All [=credentials=], [=presentations=], and encapsulated objects SHOULD
specify, or be associated with, additional more narrow [=types=] (like
`ExampleDegreeCredential`, for example) so software systems can
more easily detect and process this additional information.
        </p>

        <p>
When processing encapsulated objects defined in this specification, (for
example, objects associated with the `credentialSubject` object or
deeply nested therein), software systems SHOULD use the [=type=] information
specified in encapsulating objects higher in the hierarchy. Specifically, an
encapsulating object, such as a [=credential=], SHOULD convey the associated
object [=types=] so that [=verifiers=] can quickly determine the contents
of an associated object based on the encapsulating object [=type=].
        </p>

        <p>
For example, a [=credential=] object with the `type` of
`ExampleDegreeCredential`, signals to a [=verifier=] that the
object associated with the `credentialSubject` property contains the
identifier for the:
        </p>

        <ul>
          <li>
[=Subject=] in the `id` property.
          </li>
          <li>
Type of degree in the `type` property.
          </li>
          <li>
Title of the degree in the `name` property.
          </li>
        </ul>

        <p>
This enables implementers to rely on values associated with the
`type` property for [=verification=] purposes. The expectation of
[=types=] and their associated properties should be documented in at least a
human-readable specification, and preferably, in an additional machine-readable
representation.
        </p>

        <p class="note">
The type system used in the data model described in this specification allows
for multiple ways to associate types with data. Implementers and authors are
urged to read the section on typing in the Verifiable Credentials
Implementation Guidelines [[?VC-IMP-GUIDE]].
        </p>

      </section>

      <section>
        <h3>Names and Descriptions</h3>

        <p>
When displaying a [=credential=], it can be useful to have
text provided by the [=issuer=] that furnishes the
[=credential=] with a name as well as a short description of its
purpose. The `name` and `description` [=properties=]
are meant to serve these purposes.
        </p>

        <dl>
          <dt><dfn class="export">name</dfn></dt>
          <dd>
An OPTIONAL property that expresses the name of the [=credential=]. If
present, the value of the `name` [=property=] MUST be a string or
a language value object as described in
<a href="#language-and-base-direction"></a>. Ideally, the name of a
[=credential=] is concise, human-readable, and could enable an individual to
quickly differentiate one [=credential=] from any other [=credentials=]
that they might hold.
          </dd>
          <dt><dfn class="export">description</dfn></dt>
          <dd>
An OPTIONAL property that conveys specific details about a [=credential=]. If
present, the value of the `description` [=property=] MUST be a
string or a language value object as described in
<a href="#language-and-base-direction"></a>. Ideally, the description of a
[=credential=] is no more than a few sentences in length and conveys enough
information about the [=credential=] to remind an individual of its contents
without their having to look through the entirety of the [=claims=].
          </dd>
        </dl>

        <pre class="example nohighlight vc"
          title="Usage of the name and description property"
          data-vc-vm="https://university.example/issuers/565049#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": {
    "id": "https://university.example/issuers/565049",
    "name": "Example University",
    "description": "A public university focusing on teaching examples."
  },
  "validFrom": "2015-05-10T12:30:00Z",
  "name": "Example University Degree",
  "description": "2015 Bachelor of Science and Arts Degree",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <p>
Names and descriptions also support expressing content in different languages.
To express a string with language and [=base direction=] information,
one can use an object that contains the `@value`, `@language`, and `@direction`
properties to express the text value, language tag, and base direction,
respectively. See
<a href="#language-and-base-direction"></a> for further information.
        </p>

        <pre class="example nohighlight"
          title="Usage of the name and description property">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": {
    "id": "https://university.example/issuers/565049",
    "name": [{
      "@value": "Example University",
      "@language": "en"
    }, {
      "@value": "Université de Exemple",
      "@language": "fr"
    }, {
      "@value": "جامعة المثال",
      "@language": "ar",
      "@direction": "rtl"
    }],
    "description": [{
      "@value": "A public university focusing on teaching examples.",
      "@language": "en"
    }, {
      "@value": "Une université publique axée sur l'enseignement des exemples.",
      "@language": "fr"
    }, {
      "@value": "جامعة عامة تركز على أمثلة التدريس.",
      "@language": "ar",
      "@direction": "rtl"
    }]
  },
  "validFrom": "2015-05-10T12:30:00Z",
  "name": [{
    "@value": "Example University Degree",
    "@language": "en"
  }, {
    "@value": "Exemple de Diplôme Universitaire",
    "@language": "fr"
  }, {
    "@value": "مثال الشهادة الجامعية",
    "@language": "ar",
    "@direction": "rtl"
  }],
  "description": [{
    "@value": "2015 Bachelor of Science and Arts Degree",
    "@language": "en"
  }, {
    "@value": "2015 Baccalauréat Scientifique et Arts",
    "@language": "fr"
  }, {
    "@value": "2015 بكالوريوس العلوم والآداب",
    "@language": "ar",
    "@direction": "rtl"
  }],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": [{
        "@value": "Bachelor of Science and Arts Degree",
        "@language": "en"
      }, {
        "@value": "Baccalauréat Scientifique et Arts",
        "@language": "fr"
      }, {
        "@value": "بكالوريوس العلوم والآداب",
        "@language": "ar",
        "@direction": "rtl"
      }]
    }
  }
}
        </pre>
      </section>

      <section>
        <h3>Credential Subject</h3>

        <p>
A [=verifiable credential=] contains [=claims=] about one or more
[=subjects=]. This specification defines a `credentialSubject`
[=property=] for the expression of [=claims=] about one or more
[=subjects=].
        </p>

        <p>
A [=verifiable credential=] MUST have a `credentialSubject`
[=property=].
        </p>

        <dl>
          <dt><dfn class="export"
                   id="defn-credentialSubject">credentialSubject</dfn></dt>
          <dd>
The value of the `credentialSubject` [=property=] is defined as a
set of objects where each object MUST be the [=subject=] of one or more [=claims=],
which MUST be serialized inside the `credentialSubject` [=property=].
Each object MAY
also contain an `id` to identify the [=subject=], as
described in Section <a href="#identifiers"></a>.
          </dd>
        </dl>

        <pre class="example nohighlight vc"
          title="Usage of the credentialSubject property"
          data-vc-vm="https://university.example/issuers/565049#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T00:00:00Z",
  <span class="highlight">"credentialSubject"</span>: {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <p>
It is possible to express information related to multiple [=subjects=] in a
[=verifiable credential=]. The example below specifies two [=subjects=]
who are spouses. Note the use of array notation to associate multiple
[=subjects=] with the `credentialSubject` property.
        </p>

        <pre class="example nohighlight"
          title="Specifying multiple subjects in a verifiable credential">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "RelationshipCredential"],
  "issuer": "https://example.com/issuer/123",
  "validFrom": "2010-01-01T00:00:00Z",
  "credentialSubject": <span class="highlight">[{
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "name": "Jayden Doe",
    "spouse": "did:example:c276e12ec21ebfeb1f712ebc6f1"
  }, {
    "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
    "name": "Morgan Doe",
    "spouse": "did:example:ebfeb1f712ebc6f1c276e12ec21"
  }]</span>
}
        </pre>

      </section>

      <section>
        <h3>Issuer</h3>

        <p>
This specification defines a property for expressing the [=issuer=] of
a [=verifiable credential=].
        </p>

        <p>
A [=verifiable credential=] MUST have an `issuer` [=property=].
        </p>

        <dl>
          <dt><var id="defn-issuer">issuer</var></dt>
          <dd>
The value of the `issuer` [=property=] MUST be either a
[=URL=], or an object containing an `id` [=property=]
whose value is a [=URL=]; in either case, the issuer selects this
[=URL=] to identify itself in a globally unambiguous
way. It is RECOMMENDED that the [=URL=] be one which, if dereferenced,
results in a controller document, as defined in [[VC-DATA-INTEGRITY]] or
[[VC-JOSE-COSE]], about the [=issuer=] that can be used to [=verify=] the
information expressed in the [=credential=].
          </dd>
        </dl>

        <pre class="example nohighlight vc" title="Usage of issuer property"
          data-vc-vm="https://university.example/issuers/14#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  <span class="highlight">"issuer": "https://university.example/issuers/14"</span>,
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <p>
It is also possible to express additional information about the issuer by
associating an object with the issuer property:
        </p>

        <pre class="example nohighlight vc"
          title="Usage of issuer expanded property"
          data-vc-vm="did:example:76e12ec712ebc6f1c221ebfeb1f#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  <span class="highlight">"issuer": {
    "id": "did:example:76e12ec712ebc6f1c221ebfeb1f",
    "name": "Example University"
  }</span>,
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <p class="note">
The value of the `issuer` [=property=] can also be a JWK (for
example, `"https://example.com/keys/foo.jwk"`) or a [=DID=] (for
example, `"did:example:abfe13f712120431c276e12ecab"`).
        </p>

      </section>

      <section>
        <h3>Validity Period</h3>

        <p>
This specification defines the `validFrom` [=property=] to help an
issuer to express the date and time when a [=credential=] becomes valid and
the `validUntil` [=property=] for expressing the date and time
when a [=credential=] ceases to be valid.
        </p>

        <p>
When comparing dates and times, the calculation is done "temporally", which
means that the string value is converted to a "temporal value" which exists
as a point on a timeline. Temporal comparisons are then performed by checking
to see where the date and time being compared is in relation to
a particular point on the timeline.
        </p>

        <dl>
          <dt><var id="defn-validFrom">validFrom</var></dt>
          <dd>
If present, the value of the `validFrom` [=property=] MUST be an
[<a data-cite="XMLSCHEMA11-2#dateTime">XMLSCHEMA11-2</a>]
`dateTimeStamp` string value representing the date and time the
[=credential=] becomes valid, which could be a date and time in the future or
in the past. Note that this value represents the earliest point in time at which
the information associated with the `credentialSubject`
[=property=] becomes valid. If a `validUntil` value also exists, the
`validFrom` value MUST express a datetime that is temporally the same or earlier
than the datetime expressed by the `validUntil` value.
          </dd>
          <dt><var id="defn-validUntil">validUntil</var></dt>
          <dd>
If present, the value of the `validUntil` [=property=] MUST be an
[<a data-cite="XMLSCHEMA11-2#dateTimeStamp">XMLSCHEMA11-2</a>]
`dateTimeStamp` string value representing the date and time the
[=credential=] ceases to be valid, which could be a date and time in the past
or in the future. Note that this value represents the latest point in time at
which the information associated with the `credentialSubject`
[=property=] is valid. If a `validFrom` value also exists, the `validUntil`
value MUST express a datetime that is temporally the same or later than the
datetime expressed by the `validFrom` value.
          </dd>
        </dl>

        <pre class="example nohighlight vc"
          title="Usage of validFrom and validUntil property"
          data-vc-vm="https://university.example/issuers/14#key-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  <span class="highlight">"validFrom": "2010-01-01T19:23:24Z"</span>,
  <span class="highlight">"validUntil": "2020-01-01T19:23:24Z"</span>,
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <p class="note">
If `validFrom` and `validUntil` are not present, the
[=verifiable credential=] validity period is considered valid
indefinitely. In such cases, the [=verifiable credential=] is assumed to be
valid from the time the `verifiable credential` was created.
        </p>

        <h4>Representing Time</h4>

        <p>
Implementers are urged to understand that representing and processing time
values is not as straight-forward as it might seem and have a variety of
idiosyncrasies that are not immediately obvious nor uniformly observed in
different regions of the world. For example:
        </p>

        <ul>
          <li>
Calendaring systems other than the Gregorian calendar are actively used by
various regions.
          </li>
          <li>
When processing Daylight Saving/Summer Time, it is important to understand that
1) it is not observed in all regions, 2) it does not necessarily begin or end on
the same day or at the same time of day, and 3) the amount or direction of the
adjustment does not always match other similar regions.
          </li>
          <li>
Leap seconds might not be taken into account in all software systems, especially
for dates and times that precede the introduction of the leap second. Leap
seconds can affects highly sensitive systems that depend on the exact
millisecond offset from the epoch. However, note that for most applications the
only moment in time that is affected is the one second period of the leap second
itself. That is, the moment after the most recent leap second can always be
represented as the first moment of the next day (for example,
`2023-01-01T00:00:00Z`), regardless of whether the system in question
understands leap seconds.
          </li>
        </ul>

        <p>
These are just a few examples that illustrate that the actual time of day, as
would be seen on a clock on the wall, can exist in one region but not exist in
another region. For this reason, implementers are urged to use time values
that are more universal, such as values anchored to the `Z` time zone over
values that are affected by Daylight Saving/Summer Time.
        </p>

        <p>
This specification attempts to increase the number of universally recognized
combinations of dates and times, and reduce the potential for
misinterpretation of time values, by utilizing the
`dateTimeStamp` construction first established by the [<a
data-cite="XMLSCHEMA11-2#dateTimeStamp">XMLSCHEMA11-2</a>] specification. In
order to reduce misinterpretations between different time zones, all time values
expressed in [=conforming documents=] SHOULD be specified in `dateTimeStamp`
format, either in Universal Coordinated Time (UTC), denoted by a `Z` at the end
of the value, or with a time zone offset relative to UTC. Time values that are
incorrectly serialized without an offset MUST be interpreted as UTC. Examples of
valid time zone offsets relative to UTC include `Z`, `+01:00`, `-08:00`, and
`+14:00`. See the regular expression at the end of this section for a formal
definition of all acceptable values.
        </p>

        <p>
Time zone definitions are occasionally changed by their governing body. When
replacing or issuing new [=verifiable credentials=], implementers are advised
to ensure that changes to local time zone rules do not result in unexpected gaps
in validity. For example, consider the zone `America/Los_Angeles`, which has
a raw offset of UTC-8 and had voted to stop observing daylight savings time in
the year 2024. A given [=verifiable credential=] that had a `validUtil`
value of `2024-07-12T12:00:00-07:00`, might be re-issued to have a
`validFrom` value of `2024-07-12T12:00:00-08:00`, which would create a gap of
an hour where the [=verifiable credential=] would not be valid.
        </p>

        <p>
Implementers that desire to check `dateTimeStamp` values for validity
can use the regular expression provided below, which is reproduced from the [<a
data-cite="XMLSCHEMA11-2#dateTimeStamp">XMLSCHEMA11-2</a>] specification for
convenience. To avoid doubt, the regular expression in [[XMLSCHEMA11-2]] is the
normative definition. Implementers are advised that not all
`dateTimeStamp` values that pass the regular expression below are
valid moments in time. For example, the regular expression below allows for 31
days in every month, which allows for leap years, and leap seconds, as well as
days in places where they do not exist. That said, modern system libraries that
generate `dateTimeStamp` values are often error-free in their
generation of valid `dateTimeStamp` values. The regular
expression shown below (minus the whitespace included here for readability),
is often adequate when processing library-generated dates and times on
modern systems.
        </p>

        <pre class="example nohighlight"
          title="Regular expression to detect a valid XML Schema 1.1: Part 2 dateTimeStamp">
-?([1-9][0-9]{3,}|0[0-9]{3})
-(0[1-9]|1[0-2])
-(0[1-9]|[12][0-9]|3[01])
T(([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9](\.[0-9]+)?|(24:00:00(\.0+)?))
(Z|(\+|-)((0[0-9]|1[0-3]):[0-5][0-9]|14:00))
        </pre>

      </section>

      <section>
        <h3>Securing Mechanisms</h3>

        <p>
This specification recognizes two classes of securing mechanisms: those that use
enveloping proofs and those that use embedded proofs. An
<dfn class="export">enveloping proof</dfn> is one that wraps a serialization of
this data model. One such enveloping proof mechanism is elaborated on in the
[[[VC-JOSE-COSE]]] [[VC-JOSE-COSE]] specification. An
<dfn class="export">embedded proof</dfn> is a mechanism where
the proof is included in the data model. One such embedded proof mechanism
is [[[VC-DATA-INTEGRITY]]] [[VC-DATA-INTEGRITY]]. These two classes of securing
mechanisms are not mutually exclusive. Securing mechanism specifications other
than those referred to previously might also be defined, as necessary.
        </p>

      </section>

      <section>
        <h3>Proofs</h3>

        <p>
This specification defines the `proof` property as an extension point for the
expression of <a href="#dfn-embedded-proof">embedded proofs</a>.
It is up to each securing mechanism to specify whether or not to use it, and
if so, how it is to be used.
        </p>

        <dl>
          <dt>|proof|</dt>
          <dd>
One or more cryptographic proofs that can be used to detect tampering and verify
the authorship of a [=verifiable credential=] or a <a>verifiable
presentation</a>. Each proof is a separate [=named graph=]
(referred to as a <dfn class="export">proof graph</dfn>) containing a single
proof. The specific method used for an [=embedded proof=] MUST be identified
using the `type` [=property=].
          </dd>
        </dl>

        <p>
A proof for a [=verifiable credential=] covers all [=claims=]
included in the corresponding [=verifiable credential graph=].
See <a href="#presentations-0"></a> for the case when the property is used for a
[=verifiable presentation=].
        </p>

        <p>
Methods of securing [=verifiable credentials=] or
[=verifiable presentations=] that embed a proof in the data model MAY use
the `proof` [=property=]. Methods of securing <a>verifiable
credentials</a> or [=verifiable presentations=] that use an <a>enveloping
proof</a> MAY use the `proof` [=property=].
        </p>

        <p>
Because the method used for a mathematical proof varies by representation
language and the technology used, the set of name-value pairs that is expected
as the value of the `proof` [=property=] will vary accordingly.
For example, if digital signatures are used for the proof mechanism, the
`proof` [=property=] is expected to have name-value pairs that
include a signature, a reference to the signing entity, and a representation of
the signing date. The example below uses Ed25519 digital signatures.
        </p>

        <pre class="example nohighlight"
          title="Usage of the proof property on a verifiable credential">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://example.gov/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"proof": {
    "type": "DataIntegrityProof",
    "cryptosuite": "eddsa-rdfc-2022",
    "created": "2021-11-13T18:19:39Z",
    "verificationMethod": "https://university.example/issuers/14#key-1",
    "proofPurpose": "assertionMethod",
    "proofValue": "z58DAdFfa9SkqZMVPxAQp...jQCrfFPP2oumHKtz"
  }</span>
}
        </pre>

      </section>

      <section>
        <h3>Status</h3>

        <p>
This specification defines the following `credentialStatus`
[=property=] for the discovery of information about the current status of a
[=verifiable credential=], such as whether it is suspended or revoked.
        </p>

        <dl>
          <dt><var id="defn-credentialStatus">credentialStatus</var></dt>
          <dd>
If present, the value of the `credentialStatus` [=property=] MUST
include the following:

            <ul>
              <li>
`id` [=property=], which MUST be a [=URL=] which MAY be
dereferenced.
              </li>
              <li>
`type` [=property=], which expresses the [=credential=] status
type.
              </li>
            </ul>
          </dd>
        </dl>

        <p>
The precise content of the [=credential=] status information is determined by
the specific `credentialStatus` [=type=] definition, and varies
depending on factors such as whether it is simple to implement or if it is
privacy-enhancing. It is expected that the value will provide enough information
to determine the current status of the [=credential=] and that machine
readable information will be retrievable from the URL. For example, the object
could contain a link to an external document which notes whether or not the
[=credential=] is suspended or revoked.
        </p>

        <pre class="example nohighlight"
          title="Usage of the status property">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://w3id.org/vc/status-list/2021/v1"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"credentialStatus": {
    "id": "https://university.example/credentials/status/3#94567",
    "type": "StatusList2021Entry",
    "statusPurpose": "revocation",
    "statusListIndex": "94567",
    "statusListCredential": "https://university.example/credentials/status/3"
  }</span>
}
        </pre>

        <p>
Defining the data model, formats, and protocols for status schemes are out of
scope for this specification. A Verifiable Credential Specifications Directory
[[?VC-SPECS]] exists that contains available status schemes
for implementers who want to implement [=verifiable credential=]
status checking.
        </p>

        <p>
Specification authors that create status schemes are provided the following
guideline:
        </p>

        <ul>
          <li>
Status schemes MUST NOT be implemented in ways that enable tracking of
individuals, such as an [=issuer=] being notified (either directly or
indirectly) when a [=verifier=] is interested in a particular [=holder=]
or [=subject=]. Unacceptable approaches include "phoning home," such that
every use of a credential contacts the [=issuer=] of the credential to
check the status for a specific individual, or "pseudonymity reduction,"
such that every use of the credential causes a request for information
from the [=issuer=] that can be used by the [=issuer=] to deduce
[=verifier=] interest in a specific individual.
          </li>
        </ul>

      </section>

      <section>
        <h3>Presentations</h3>

        <p>
[=Verifiable presentations=] MAY be used to aggregate information from
multiple [=verifiable credentials=].
        </p>
        <p>
[=Verifiable presentations=] SHOULD be extremely short-lived, and bound to a
challenge provided by a [=verifier=]. Details for accomplishing this depend
on the securing mechanism, the transport protocol, and [=verifier=] policies.
Unless additional requirements are defined by the particular securing mechanism
or embedding protocol, a [=verifier=] cannot generally assume that the
[=verifiable presentation=] has any correlation with the presented
[=verifiable credentials=].
        </p>

        <p>
The [=default graph=] of a [=verifiable presentation=] is also referred to
as the <dfn>verifiable presentation graph</dfn>.
        </p>


        <p>
The following properties are defined for a [=verifiable presentation=]:
        </p>

        <dl>
          <dt>|id|</dt>
          <dd>
The `id` [=property=] is optional. It MAY be used to provide a
unique identifier for the [=verifiable presentation=]. If present, the
normative guidance in Section <a href="#identifiers"></a> MUST be followed.
          </dd>
          <dt>|type|</dt>
          <dd>
The `type` [=property=] MUST be present. It is used to express the
type of [=verifiable presentation=]. One value of this property MUST be
`VerifiablePresentation`, but additional types MAY be included. The
related normative guidance in Section <a href="#types"></a> MUST be followed.
          </dd>
          <dt><var id="defn-verifiableCredential">verifiableCredential</var></dt>
          <dd>
The `verifiableCredential` [=property=] MAY be present. The value
MUST be one or more [=verifiable credential=] and/or
<a href="#enveloped-verifiable-credentials">enveloped verifiable credential</a>
objects (to be clear, the values MUST NOT be non-object values such as
numbers, strings, or URLs). These types of objects are called
<a href="#verifiable-credential-graphs">verifiable credential graphs</a> and
MUST express information that is secured using a
<a href="#securing-mechanisms">securing mechanism</a>.
See Section <a href="#verifiable-credential-graphs"></a> for further details.
          </dd>
          <dt><var id="defn-holder">holder</var></dt>
          <dd>
The [=verifiable presentation=] MAY include a `holder`
[=property=]. If present, the value MUST be either a [=URL=] or an object
containing an `id` [=property=]. It is RECOMMENDED that the
[=URL=] in the `holder` or its `id` be one which, if
dereferenced, results in a document containing machine-readable information
about the [=holder=] that can be used to [=verify=] the information
expressed in the [=verifiable presentation=].
If the `holder` [=property=] is absent, information about the
[=holder=] is expected to either be obtained via the securing mechanism, or
to not pertain to the [=validation=] of the [=verifiable presentation=].
          </dd>
          <dt>|proof|</dt>
          <dd>
            <p>
The [=verifiable presentation=] MAY include a `proof`
[=property=], which refers to a separate [=named graph=] containing a
single proof. The specific method used for the MUST be identified using the
`type` [=property=].
<!-- If present, the value SHOULD be used to express a securing mechanism, such
as those listed in the Verifiable Credentials Specifications Directory
[[?VC-SPECS]]. -->
The proof covers of all claims in the following [=graphs=]:
            </p>
            <ul>
              <li>
the [=verifiable presentation graph=];
              </li>
              <li>
all [=verifiable credential graphs=] referred to by the
`verifiableCredential` property of the presentation, as well as their
corresponding [=proof graphs=].
              </li>
            </ul>
          </dd>
        </dl>

        <p>
The example below shows a [=verifiable presentation=]:
        </p>

        <pre class="example nohighlight" title="Basic structure of a presentation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "urn:uuid:3978344f-8596-4c3a-a978-8fcaba3903c5",
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  <span class="highlight">"verifiableCredential": [{ <span class="comment">...</span> }]
}
        </pre>

        <p>
The contents of the `verifiableCredential` [=property=] shown
above are <a href="#verifiable-credential-graphs">verifiable credential
graphs</a>, as described by this specification. The contents of the
`proof` [=property=] are proof graphs, as described by the Data
Integrity [[VC-DATA-INTEGRITY]] specification. An example of a <a>verifiable
presentation</a> using the JWT proof mechanism is provided in the Securing
Verifiable Credentials using JOSE and COSE [[?VC-JOSE-COSE]] specification.
        </p>

        <section>
          <h4>Enveloped Verifiable Credentials</h4>

          <p>
It is possible for a [=verifiable presentation=] to include one or more
[=verifiable credentials=] that have been secured using a securing mechanism
that "envelopes" the payload, such as [[[?VC-JOSE-COSE]]] [[?VC-JOSE-COSE]].
This can be accomplished by associating the `verifiableCredential` property with
an object that has a `type` of `EnvelopedVerifiableCredential`.
          </p>

          <dl>
            <dt id="defn-EnvelopedVerifiableCredential">EnvelopedVerifiableCredential</dt>
            <dd>
Used to associate an object containing an enveloped [=verifiable credential=]
with the `verifiableCredential` property in a [=verifiable presentation=].
The `@context` property of the object MUST be present and include a context,
such as the <a href="#base-context">base context for this specification</a>,
that defines at least the `id`, `type`, and `EnvelopedVerifiableCredential`
terms as defined by the base context provided by this specification. The `id`
value of the object MUST be a `data:` URL [[RFC2397]] that expresses a secured
[=verifiable credential=] using an
<a href="#dfn-enveloping-proof">enveloping</a> security scheme, such as
[[[VC-JOSE-COSE]]] [[VC-JOSE-COSE]]. The `type` value of the object MUST be
`EnvelopedVerifiableCredential`.
            </dd>
          </dl>

        <p>
The example below shows a [=verifiable presentation=] that contains an
enveloped [=verifiable credential=]:
        </p>

        <pre class="example nohighlight" title="Basic structure of a presentation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  <span class="highlight">"verifiableCredential": [{
    "@context": "https://www.w3.org/ns/credentials/v2",
    "id": "data:application/vc+ld+json+sd-jwt;QzVjV...RMjU",
    "type": "EnvelopedVerifiableCredential"
  }]</span>
}
        </pre>

        </section>

        <section>
          <h4>Presentations Using Derived Credentials</h4>

          <p>
Some zero-knowledge cryptography schemes might enable [=holders=] to
indirectly prove they hold [=claims=] from a [=verifiable credential=]
without revealing all claims in that [=verifiable credential=]. In these
schemes, a [=verifiable credential=] might be used to derive presentable
data, which is cryptographically asserted such that a [=verifier=] can trust
the value if they trust the [=issuer=].
          </p>
          <p>
Some selective disclosure schemes can share a subset of [=claims=]
derived from a [=verifiable credential=].
          </p>

          <p class="note">
For an example of a ZKP-style [=verifiable presentation=] containing
derived data instead of directly embedded [=verifiable credentials=], see
Section <a href="#zero-knowledge-proofs"></a>.
          </p>

          <figure>
            <img style="margin: auto; display: block; width: 50%;"
                 src="diagrams/claim-example-2.svg" alt="Pat has a property
                 overAge whose value is 21">
            <figcaption style="text-align: center;">
A basic claim expressing that Pat is over the age of 21.
            </figcaption>
          </figure>
        </section>
        <section>
          <h4>Presentations Including Holder Claims</h4>
          <p>
A [=holder=] MAY use the `verifiableCredential` [=property=] in
a [=verifiable presentation=] to include [=verifiable credentials=] from
any [=issuer=], including themselves. When the [=issuer=] of a
[=verifiable credential=] is the [=holder=], the [=claims=] in that
[=verifiable credential=] are considered to be <em>self-asserted</em>.
Such self-asserted claims can be secured by the same mechanism that secures
the [=verifiable presentation=] in which they are included or by any
mechanism usable for other [=verifiable credentials=].
          </p>
          <p>
The <a href="#dfn-subjects">subject(s)</a> of these self-asserted [=claims=]
are not limited, so these [=claims=] can include statements about the
[=holder=], one of the other included [=verifiable credentials=], or even
the [=verifiable presentation=] in which the self-asserted <a>verifiable
credential</a> is included. In each case, the `id` [=property=]
is used to identify the specific [=subject=], in the object where the
[=claims=] about it are made, just as it is done in
[=verifiable credentials=] that are not self-asserted.
          </p>
          <p>
A [=verifiable presentation=] that includes a self-asserted
[=verifiable credential=] that is only secured using the same mechanism as
the [=verifiable presentation=] MUST include a `holder`
[=property=].
          </p>
          <p>
All of the normative requirements defined for [=verifiable credentials=]
apply to self-asserted [=verifiable credentials=].
          </p>
          <p>
When a self-asserted [=verifiable credential=] is secured using the same
mechanism as the [=verifiable presentation=], the value of the
`issuer` [=property=] of the [=verifiable credential=]
MUST be identical to the `holder` [=property=] of the
[=verifiable presentation=].
          </p>
          <p>
The example below shows a [=verifiable presentation=] that embeds a
self-asserted [=verifiable credential=] that is secured using the same
mechanism as the [=verifiable presentation=].
          </p>

          <pre class="example nohighlight" title="A verifiable presentation, secured with an embedded proof, with a self-asserted verifiable credential">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  "holder": "did:example:12345678",
  "verifiableCredential": [{
    "@context": "https://www.w3.org/ns/credentials/v2",
    "type": ["VerifiableCredential", "ExampleFoodPreferenceCredential"],
    "issuer": "did:example:12345678",
    "credentialSubject": {
      "favoriteCheese": "Gouda"
    },
    { <span class="comment">...</span> }
  }],
  "proof": [{ <span class="comment">...</span> }]
}
          </pre>
          <p>
The example below shows a [=verifiable presentation=] that embeds a
self-asserted [=verifiable credential=] that holds [=claims=] about the
[=verifiable presentation=]. It is secured using the same mechanism as the
[=verifiable presentation=].
          </p>

          <pre class="example nohighlight" title="A verifiable presentation, secured with an embedded proof, with a self-asserted verifiable credential about the verifiable presentation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "type": ["VerifiablePresentation", "ExamplePresentation"],
  <span class="highlight">"id": "urn:uuid:313801ba-24b7-11ee-be02-ff560265cf9b"</span>,
  "holder": "did:example:12345678",
  "verifiableCredential": [{
    "@context": "https://www.w3.org/ns/credentials/v2",
    "type": ["VerifiableCredential", "ExampleAssertCredential"],
    "issuer": "did:example:12345678",
    "credentialSubject": {
      <span class="highlight">"id": "urn:uuid:313801ba-24b7-11ee-be02-ff560265cf9b"</span>,
      "assertion": "This VP is submitted by the subject as evidence of a legal right to drive"
    },
    "proof": { <span class="comment">...</span> }
  }],
  "proof": { <span class="comment">...</span> }
}
          </pre>
        </section>
      </section>

      <section>
        <h3>Data Schemas</h3>

        <p>
Data schemas are useful when enforcing a specific structure on a given
collection of data. There are at least two types of data schemas that this
specification considers:
        </p>

        <ul>
          <li>
Data verification schemas, which are used to establish that the structure
and contents of a [=credential=] or [=verifiable credential=] conform to a
published schema.
          </li>
          <li>
Data encoding schemas, which are used to map the contents of a
[=verifiable credential=] to an alternative representation format, such as a
format used in a zero-knowledge proof.
          </li>
        </ul>

        <p>
It is important to understand that data schemas serve a different purpose from
the `@context` property, which neither enforces data structure or
data syntax, nor enables the definition of arbitrary encodings to alternate
representation formats.
        </p>
        <p>
This specification defines the following [=property=] for the expression of a
data schema, which can be included by an [=issuer=] in
the [=verifiable credentials=] that it issues:
        </p>

        <dl>
          <dt><var id="defn-credentialSchema">credentialSchema</var></dt>
          <dd>
            <p>
The value of the `credentialSchema` [=property=] MUST be one or
more data schemas that provide [=verifiers=] with enough information to
determine whether the provided data conforms to the provided schema(s). Each
`credentialSchema` MUST specify its `type` (for example,
`JsonSchema`), and an `id` [=property=]
that MUST be a [=URL=] identifying the schema file. The precise contents of
each data schema is determined by the specific type definition.
            </p>
            <p>
If multiple schemas are present, validity is determined according to the
processing rules outlined by each associated `credentialSchema`
`type` property.
            </p>
          </dd>
        </dl>

        <p class="note">
The `credentialSchema` [=property=] provides an opportunity to
annotate type definitions or lock them to specific versions of the vocabulary.
Authors of [=verifiable credentials=] can include a static version of their
vocabulary using `credentialSchema` that is locked to some content
integrity protection mechanism. The `credentialSchema`
[=property=] also makes it possible to perform syntactic checking on the
[=credential=] and to use [=verification=] mechanisms such as JSON Schema
[[?VC-JSON-SCHEMA]] validation.
        </p>

        <pre class="example nohighlight"
          title="Usage of the credentialSchema property to perform JSON schema validation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential", "ExamplePersonCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    },
    "alumniOf": {
      "name": "Example University"
    }
  },
  <span class="highlight">"credentialSchema": [{
    "id": "https://example.org/examples/degree.json",
    "type": "JsonSchema"
  },
  {
    "id": "https://example.org/examples/alumni.json",
    "type": "JsonSchema"
  }]</span>
}
        </pre>

        <p>
In the example above, the [=issuer=] is specifying a
`credentialSchema`, which points to a [[?VC-JSON-SCHEMA]] file that
can be used by a [=verifier=] to determine whether the
[=verifiable credential=] is well-formed.
        </p>

        <p class="note" >
For information about linkages to JSON Schema [[?VC-JSON-SCHEMA]] or other
optional schema validation mechanisms, see the Verifiable Credentials
Implementation Guidelines [[VC-IMP-GUIDE]] document.
        </p>

        <p>
Data schemas can also be used to specify mappings to other formats, such as
those used to perform zero-knowledge proofs. For more information on using the
`credentialSchema` [=property=] with zero-knowledge proofs,
see Section <a href="#zero-knowledge-proofs"></a>.
        </p>

        <pre class="example nohighlight" title="Usage of the credentialSchema property to perform zero-knowledge validation">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"credentialSchema": {
    "id": "https://example.org/examples/degree",
    "type": "ZkpExampleSchema2018"
  }</span>,
  "proof": { <span class="comment">...</span> }
}
        </pre>

        <p>
In the example above, the [=issuer=] is specifying a
`credentialSchema` pointing to a means of transforming the input data
into a format which can then be used by a [=verifier=] to determine whether
the proof provided with the [=verifiable credential=] is well-formed.
        </p>


      </section>

    </section>

    <section>
      <h2>Advanced Concepts</h2>

      <p>
Building on the concepts introduced in Section <a href="#basic-concepts"></a>,
this section explores more complex topics about [=verifiable credentials=].
      </p>

      <section class="informative">
        <h3>Lifecycle Details</h3>

        <p>
Section <a href="#ecosystem-overview"></a> provided an overview of the
[=verifiable credential=] ecosystem. This section provides more detail about
how the ecosystem is envisaged to operate.
        </p>

        <figure id="life-cycle-details">
          <img style="margin: auto; display: block; width: 85%;"
         src="diagrams/ecosystemdetail.svg" alt="diagram showing how
         credentials flow from issuer to holder, and optionally
         from one holder to another; and how
         presentations flow from holder to verifier, where
         all parties can use information from a logical
         verifiable data registry">
          <figcaption style="text-align: center;">
            The roles and information flows for this specification.
          </figcaption>
        </figure>

        <p class="issue" title="Validation needs to be added to image.">
The process of validation needs to be added to the image above.
       </p>

        <p>
The roles and information flows in the [=verifiable credential=] ecosystem
are as follows:
        </p>

        <ul>
          <li>
An [=issuer=] <dfn class="export" data-lt="issue">issues</dfn> a
[=verifiable credential=] to a [=holder=]. Issuance always occurs before
any other actions involving a [=credential=].
          </li>
          <li>
A [=holder=] might <dfn class="export"
data-lt="transfers">transfer</dfn> one or more of its <a>verifiable
credentials</a> to another [=holder=].
          </li>
          <li>
A [=holder=] <dfn class="export" data-lt="present">presents</dfn> one or
more of its [=verifiable credentials=] to a [=verifier=], optionally
inside a [=verifiable presentation=].
          </li>
          <li>
A [=verifier=] [=verifies=] the authenticity of the presented
[=verifiable presentation=] and [=verifiable credentials=] and
checks any <a href="#status">credential status</a> (if present)
of the [=verifiable credentials=].
          </li>
          <li>
After [=verification=], a [=verifier=] validates the relevant claims in
presented [=verifiable credentials=], using their own business logic to
evaluate which issuers are appropriate for which claims and which subjects are
appropriate for the requested use.
         </li>
         <li>
An [=issuer=] might <dfn class="export" data-lt="revoke">revoke</dfn> a
[=verifiable credential=].
          </li>
          <li>
A [=holder=] might <dfn class="export" data-lt="delete">delete</dfn> a
[=verifiable credential=].
          </li>
        </ul>

        <p class="note">
The order of the actions above is not fixed, and some actions might be taken
more than once. Such action-recurrence might be immediate or at any later
point.
        </p>

        <p>
The most common sequence of actions is envisioned to be:
        </p>

        <ol>
          <li>
An [=issuer=] <a href="#lifecycle-details">issues</a> a <a>verifiable
credential</a> to a [=holder=].
          </li>
          <li>
The [=holder=] <a href="#lifecycle-details">presents</a> to a
[=verifier=].
          </li>
          <li>
The [=verifier=] <a href="#lifecycle-details">verifies</a>.
          </li>
          <li>
The [=verifier=] <a href="#lifecycle-details">validates</a> claims.
          </li>
          <li>
The [=verifier=] applies valid claims</a>.
          </li>
        </ol>

        <p>
This specification does not define any protocol for transferring
[=verifiable credentials=] or [=verifiable presentations=], but assuming
other specifications do specify how they are transferred between entities, then
this Verifiable Credential Data Model is directly applicable.
        </p>

        <p>
This specification neither defines an authorization framework nor
does it restrict the business decisions that a [=verifier=] might make
after [=verifying=] a [=verifiable credential=] or <a>verifiable
presentation</a>. Rather, [=verifiers=]
apply their own business rules before treating any claim as valid,
taking into account the [=holder=], the [=issuer=] of the
[=verifiable credential=], the claims of the
[=verifiable credential=], and the [=verifier's=] own policies.
        </p>

        <p>
In particular, Sections <a href="#terms-of-use"></a> and
the <a href="https://www.w3.org/TR/vc-imp-guide/#subject-holder-relationships">
Subject-Holder Relationships</a> section in the Verifiable Credentials
Implementation Guide [[VC-IMP-GUIDE]] specify how a [=verifier=] can
determine:
        </p>

        <ul>
          <li>
Whether the [=holder=] is a [=subject=] of a [=verifiable credential=].
          </li>
          <li>
The relationship between the [=subject=] and the [=holder=].
          </li>
          <li>
Whether the original [=holder=] passed a [=verifiable credential=] to a
subsequent [=holder=].
          </li>
          <li>
Any restrictions using the [=verifiable credentials=] by the [=holder=]
or [=verifier=].
          </li>
        </ul>
      </section>

      <section class="informative">
        <h3>Trust Model</h3>

        <p>
The [=verifiable credentials=] trust model is as follows:
        </p>

        <ul>
          <li>
The [=verifier=] trusts the [=issuer=] to issue the [=credential=] that
it received. To establish this trust, a [=credential=] is expected to either:
            <ul>
              <li>
Include a <a href="#proofs-signatures">proof</a> establishing that the
[=issuer=] generated the [=credential=] (that is, it is a
[=verifiable credential=]), or
              </li>
              <li>
Have been transmitted in a way clearly establishing that the [=issuer=]
generated the [=verifiable credential=] and that the
[=verifiable credential=] was not tampered with in transit or storage. This
trust could be weakened depending on the risk assessment of the [=verifier=].
              </li>
            </ul>
          </li>
          <li>
All [=entities=] trust the [=verifiable data registry=] to be
tamper-evident and to be a correct record of which data is controlled by which
[=entities=].
          </li>
          <li>
The [=holder=] and [=verifier=] trust the [=issuer=] to issue
true (that is, not false) [=credentials=] about the [=subject=], and to
revoke them quickly when appropriate.
          </li>
          <li>
The [=holder=] trusts the [=repository=] to store [=credentials=]
securely, to not release them to anyone other than the [=holder=], and to not
corrupt or lose them while they are in its care.
          </li>
        </ul>

        <p>
This trust model differentiates itself from other trust models by ensuring
the:
        </p>

        <ul>
          <li>
[=Issuer=] and the [=verifier=] do not need to trust the
[=repository=]
          </li>
          <li>
[=Issuer=] does not need to know or trust the [=verifier=].
          </li>
        </ul>

        <p>
By decoupling the trust between the [=identity provider=] and the
[=relying party=] a more flexible and dynamic trust model is created such
that market competition and customer choice is increased.
        </p>

        <p>
For more information about how this trust model interacts with various threat
models studied by the Working Group, see the Verifiable Credentials Use Cases
document [[VC-USE-CASES]].
        </p>

        <p class="note">
The data model detailed in this specification does not imply a transitive trust
model, such as that provided by more traditional Certificate Authority trust
models. In the Verifiable Credentials Data Model, a [=verifier=] either
directly trusts or does not trust an [=issuer=]. While it is possible to
build transitive trust models using the Verifiable Credentials Data Model,
implementers are urged to
<a href="https://datatracker.ietf.org/doc/draft-iab-web-pki-problems/">learn
about the security weaknesses</a> introduced by
<a href="https://www.usenix.org/conference/imc-05/perils-transitive-trust-domain-name-system">
broadly delegating trust</a> in the manner adopted by Certificate Authority
systems.
        </p>
      </section>

      <section>
        <h3>Extensibility</h3>

        <p>
One of the goals of the Verifiable Credentials Data Model is to enable
permissionless innovation. To achieve this, the data model needs to be
extensible in a number of different ways. The data model is required to:
        </p>

        <ul>
          <li>
Model complex multi-entity relationships through the use of a [=graph=]-based
data model.
          </li>
          <li>
Extend the machine-readable vocabularies used to describe information in the
data model, without the use of a centralized system for doing so, through the
use of [[?LINKED-DATA]].
          </li>
          <li>
Support multiple types of cryptographic proof formats through the use of JOSE or
COSE [[VC-JOSE-COSE]], Data Integrity Proofs [[VC-DATA-INTEGRITY]], and a
variety of cryptographic suites listed in the Verifiable Credential
Specifications Directory [[?VC-SPECS]].
          </li>
          <li>
Provide all of the extensibility mechanisms outlined above in a data format that
is popular with software developers and web page authors, and is enabled through
the use of [[JSON-LD]].
          </li>
        </ul>

        <p>
This approach to data modeling is often called an
<em>open world assumption</em>, meaning that any entity can say anything about
any other entity. While this approach seems to conflict with building simple and
predictable software systems, balancing extensibility with program correctness
is always more challenging with an open world assumption than with closed
software systems.
        </p>

        <p>
The rest of this section describes, through a series of examples, how both
extensibility and program correctness are achieved.
        </p>

        <p>
Let us assume we start with the [=verifiable credential=] shown below.
        </p>

        <pre class="example nohighlight vc"
          title="A simple credential"
          data-vc-vm="https://university.example/issuers/14#keys-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://example.com/credentials/4643",
  "type": ["VerifiableCredential"],
  "issuer": "https://example.com/issuers/14",
  "validFrom": "2018-02-24T05:28:04Z",
  "credentialSubject": {
    "id": "did:example:abcdef1234567",
    "name": "Jane Doe"
  }
}
        </pre>

        <p>
This [=verifiable credential=] states that the [=entity=] associated with
`did:example:abcdef1234567` has a `name` with a value of
`Jane Doe`.
        </p>

        <p>
Now let us assume a developer wants to extend the [=verifiable credential=]
to store two additional pieces of information: an internal corporate reference
number, and Jane's favorite food.
        </p>

        <p>
The first thing to do is to create a JSON-LD context containing two new terms,
as shown below.
        </p>

        <pre class="example nohighlight" title="A JSON-LD context">
{
  "@context": {
    "referenceNumber": "https://example.com/vocab#referenceNumber",
    "favoriteFood": "https://example.com/vocab#favoriteFood"
  }
}
        </pre>

        <p>
After this JSON-LD context is created, the developer publishes it somewhere so
it is accessible to [=verifiers=] who will be processing the
[=verifiable credential=]. Assuming the above JSON-LD context is published at
`https://example.com/contexts/mycontext.jsonld`, we can extend this
example by including the context and adding the new [=properties=] and
[=credential=] [=type=] to the [=verifiable credential=].
        </p>

        <pre class="example nohighlight"
          title="A verifiable credential with a custom extension">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2",
    <span class="highlight">"https://example.com/contexts/mycontext.jsonld"</span>
  ],
  "id": "http://example.com/credentials/4643",
  "type": ["VerifiableCredential", "CustomExt12"],
  "issuer": "https://example.com/issuers/14",
  "validFrom": "2018-02-24T05:28:04Z",
  <span class="highlight">"referenceNumber": 83294847,</span>
  "credentialSubject": {
    "id": "did:example:abcdef1234567",
    "name": "Jane Doe",
    <span class="highlight">"favoriteFood": "Papaya"</span>
  }
}
        </pre>

        <p>
This example demonstrates extending the Verifiable Credentials Data Model in a
permissionless and decentralized way. The mechanism shown also ensures that
[=verifiable credentials=] created in this way provide a mechanism to prevent
namespace conflicts and semantic ambiguity.
        </p>

        <p>
A dynamic extensibility model such as this does increase the implementation
burden. Software written for such a system has to determine whether
[=verifiable credentials=] with extensions are acceptable based on the risk
profile of the application. Some applications might accept only certain
extensions while highly secure environments might not accept any extensions.
These decisions are up to the developers of these applications and are
specifically not the domain of this specification.
        </p>

        <p>
Developers are urged to ensure that extension JSON-LD contexts are highly
available. Implementations that cannot dereference a context will produce an
error. Strategies for ensuring that extension JSON-LD contexts are always
available include using content-addressed URLs for contexts, bundling context
documents with implementations, or enabling aggressive caching of contexts.
        </p>

        <p>
Implementers are advised to pay close attention to the extension points in this
specification, such as in Sections <a href="#proofs-signatures"></a>,
<a href="#status"></a>, <a href="#data-schemas"></a>,<a href="#refreshing"></a>,
<a href="#terms-of-use"></a>, and <a href="#evidence"></a>. While this
specification does not define concrete implementations for those extension
points, the Verifiable Credential Specifications Directory [[?VC-SPECS]]
provides an unofficial, curated list of extensions that developers can use from
these extension points.
        </p>

        <section>
          <h4>Semantic Interoperability</h4>

          <ul>
            <li>
JSON-LD-based processors MUST produce an error when a JSON-LD context redefines
any term in the
<a href="https://www.w3.org/TR/json-ld/#dfn-active-context">active context</a>.
The only way to change the definition of existing terms is to introduce a new
term that clears the active context within the scope of that new term. Authors
that are interested in this feature should read about the
`@protected` feature in the JSON-LD 1.1 specification.
            </li>
          </ul>

          <p>
A human-readable document describing the expected order of values for the
`@context` [=property=] is expected to be published by any
implementer seeking interoperability. A machine-readable description
(that is, a normal JSON-LD Context document) is expected to be published
at the URL specified in the `@context` [=property=] by
JSON-LD implementers seeking interoperability.
          </p>
        </section>
      </section>

      <section>
        <h2>Integrity of Related Resources</h2>
        <p>
When including a link to an external resource in a [=verifiable credential=],
it is desirable to know whether the resource that is pointed to is the same at
signing time as it is at verification time. This applies to cases where there is
an external resource that is remotely retrieved as well as to cases where the
[=issuer=] and/or [=verifier=] may have local cached copies of a resource.
        </p>
        <p>
It is also desirable to know that the contents of the JSON-LD context(s) used in
the [=verifiable credential=] are the same when used by both the
[=issuer=] and [=verifier=].
        </p>
        <p>
To validate that a resource referenced by a [=verifiable credential=] is the
same at verification time as it is at issuing time, an implementer MAY include a
property named <code id="defn-relatedResource">relatedResource</code> that
stores an array of objects that describe additional integrity metadata about
each resource referenced by the [=verifiable credential=]. If
`relatedResource` is present, there MUST be an object in the array
for each remote resource for each context used in the verifiable credential.
        </p>
        <p class="issue" title="Mandatory listing of contexts in relatedResouce are under debate.">
The requirement that contexts be listed in `relatedResource` is currently being
debated in the VCWG. This requirement might be removed in future iterations of
the specification.
        </p>
        <p>
Each object in the `relatedResource` array MUST contain the
following: the [[URL]] to the resource named `id` and the
<code id="defn-digestSRI">digestSRI</code> information for the resource
constructed using the method specified in
<a href="https://www.w3.org/TR/SRI/#integrity-metadata">Subresource Integrity</a>.
        </p>
        <p class="issue" title="Unification of cryptographic hash expression formats are under discussion">
The Working Group is currently attempting to determine whether cryptographic hash
expression formats can be unified across all of the VCWG core specifications.
Candidates for this mechanism include `digestSRI` and `digestMultibase`. There
are arguments for and against unification that the WG is currently debating.
        </p>
        <p>
There MUST NOT be more than one object in the `relatedResource` per
`id`.
        </p>
        <p>
An object in the `relatedResource` array MAY contain a property named
`mediaType` that indicates the expected media type for the indicated
`resource`. If a `mediaType` is included, its value
SHOULD:
        </p>
        <ul>
          <li>
be a valid media type as listed in the
<a href="https://www.iana.org/assignments/media-types/media-types.xhtml">
IANA Media Types</a> registry
          </li>
          <li>
be used when retrieving the content, such as via the `Accept` HTTP Header
          </li>
          <li>
match the retrieved content media type, such as via the `Content-Type` HTTP
Header.
          </li>
        </ul>

        <p>
Any object in the [=verifiable credential=] that contains an `id` [[URL]]
property MAY be annotated with integrity information as specified in this
section by inclusion of `digestSRI`
in the object.
        </p>
        <p>
Any objects for which selective disclosure is desired SHOULD NOT be included as
an object in the `relatedResource` array.
        </p>
        <p>
Specification authors that write algorithms that fetch a resource based on the
`id` of an object inside a [=conforming document=] need to consider whether
that resource's content is vital to the validity of that document. If it is, the
specification MUST produce a validation error unless the resource has the
expected media type and its bytes hash to the expected digest.
        </p>
        <p>
Implementers are urged to consult appropriate sources, such as the
<a href="https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf">
FIPS 180-4 Secure Hash Standard</a> and the
<a href="https://media.defense.gov/2022/Sep/07/2003071834/-1/-1/0/CSA_CNSA_2.0_ALGORITHMS_.PDF">
Commercial National Security Algorithm Suite 2.0</a> to ensure that they are
chosing a current and reliable hash algorithm. At the time of this writing
`sha384` SHOULD be considered the minimum strength hash algorithm for use by
implementers.
        </p>
        <p class="issue">
The working group is discussing if we will adopt more aspects of subresource
integrity as defined in [[SRI]] is adopted into the [[JSON-LD]] specification as
noted in that specifications <a href="https://www.w3.org/TR/json-ld11/#security">
current security considerations</a> of that specification, this hash in the VC
can serve as an additional check towards ensuring that a cached context used
when issuing the VC matches the remote resource.
        </p>
        <p>
An example of a related resource integrity object referencing JSON-LD contexts.
        </p>

        <pre class="example nohighlight"
          title="Usage of the relatedResource property">
"relatedResource": [{
  "id": "https://www.w3.org/ns/credentials/v2",
  "digestSRI":
    "sha384-lHKDHh0msc6pRx8PhDOMkNtSI8bOfsp4giNbUrw71nXXLf13nTqNJoRp3Nx+ArVK",
},{
  "id": "https://www.w3.org/ns/credentials/examples/v2",
  "digestSRI":
    "sha384-zNNbQTWCSUSi0bbz7dbua+RcENv7C6FvlmYJ1Y+I727HsPOHdzwELMYO9Mz68M26",
}]
        </pre>

        <p>
An example of an object in a `credentialSubject` that is refering to an
integrity protected image.
        </p>

        <pre class="example nohighlight"
          title="An integrity-protected image that is associated with a credentialSubject">
"credentialSubject": {
  "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  "image": {
    "id": "https://university.example.org/images/58473",
    "digestSRI":
      "sha384-ZfAwuJmMgoX3s86L7x9XSPi3AEbiz6S/5SyGHJPCxWHs5NEth/c5S9QoS1zZft+J",
    "mediaType": "application/svg+xml",
  },
  ...
}
        </pre>
      </section>

      <section>
        <h3>Refreshing</h3>

        <p class="issue" title="(AT RISK) Feature depends on demonstration of independent implementations">
This feature is at risk and will be removed from the specification if at least
two independent, interoperable implementations are not demonstrated for a
single extension type by the end of the Candidate Recommendation Phase. If
this feature is removed, the property will be included in Section
<a href="#reserved-extension-points"></a>, in anticipation of future
implementation and inclusion in the specification.
        </p>

        <p>
It is useful for systems to enable the manual or automatic refresh of an expired
[=verifiable credential=]. For more information about validity periods for
[=verifiable credentials=], see Section <a href="#validity-periods"></a>.
This specification defines a `refreshService` [=property=], which
enables an [=issuer=] to include a link to a refresh service.
        </p>
        <p>
The [=issuer=] can include the refresh service as an element inside the
[=verifiable credential=] if it is intended for either the [=verifier=] or
the [=holder=] (or both), or inside the [=verifiable presentation=] if it
is intended for the [=holder=] only. In the latter case, this enables the
[=holder=] to refresh the [=verifiable credential=] before creating a
[=verifiable presentation=] to share with a [=verifier=]. In the former
case, including the refresh service inside the [=verifiable credential=]
enables either the [=holder=] or the [=verifier=] to perform future
updates of the [=credential=].
        </p>
        <p>
The refresh service is only expected to be used when either the
[=credential=] has expired or the [=issuer=] does not publish
[=credential=] status information. [=Issuers=] are advised not to put the
`refreshService` [=property=] in a [=verifiable credential=]
that does not contain public information or whose refresh service is not
protected in some way.
        </p>
        <p class="note">
Placing a `refreshService` [=property=] in a
[=verifiable credential=] so that it is available to [=verifiers=] can
remove control and consent from the [=holder=] and allow the
[=verifiable credential=] to be issued directly to the [=verifier=],
thereby bypassing the [=holder=].
        </p>

        <dl>
          <dt><var id="defn-refreshService">refreshService</var></dt>
          <dd>
The value of the `refreshService` [=property=] MUST be one or more
refresh services that provides enough information to the recipient's software
such that the recipient can refresh the [=verifiable credential=]. Each
`refreshService` value MUST specify its `type` (for
example, `ManualRefreshService2018`) and its `id`, which
is the [=URL=] of the service. There is an expectation that machine readable
information needs to be retrievable from the URL. The precise content of
each refresh service is determined by the specific `refreshService`
[=type=] definition.
          </dd>
        </dl>

        <pre class="example nohighlight"
          title="Usage of the refreshService property by an issuer">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"refreshService": {
    "id": "https://university.example/refresh/3732",
    "type": "ManualRefreshService2018"
  }</span>
}
        </pre>

        <p>
In the example above, the [=issuer=] specifies a manual
`refreshService` that can be used by directing the [=holder=] or
the [=verifier=] to `https://university.example/refresh/3732`.
        </p>

      </section>

      <section>
        <h3>Terms of Use</h3>

        <p>
Terms of use can be utilized by an [=issuer=] or a [=holder=] to
communicate the terms under which a [=verifiable credential=] or
[=verifiable presentation=] was issued. The [=issuer=] places their terms
of use inside the [=verifiable credential=]. The [=holder=] places their
terms of use inside a [=verifiable presentation=]. This specification defines
a `termsOfUse` [=property=] for expressing terms of use
information.
        </p>

        <p>
The value of the `termsOfUse` [=property=] might be used
to tell the [=verifier=] any or all of the following, among other things:
        </p>

        <ul>
          <li>
the procedures or policies that were used in issuing the <a>verifiable
credential</a>, by providing, for example, a pointer to a public location
(to avoid "phone home" privacy issues) where these procedures or policies
can be found, or the name of the standard that defines them
          </li>
          <li>
the rules and policies of the [=issuer=] that apply to the presentation
of this [=verifiable credential=] to a [=verifier=], by providing,
for example, a pointer to a pubic location (to avoid "phone home" privacy
issues) where these rules or policies can be found
          </li>
          <li>
the identity of the entity under whose authority the [=issuer=] issued
this particular [=verifiable credential=]
          </li>
        </ul>

        <dl>
          <dt><var id="defn-termsOfUse">termsOfUse</var></dt>
          <dd>
The value of the `termsOfUse` [=property=] MUST specify one or
more terms of use policies under which the creator issued the [=credential=]
or [=presentation=]. If the recipient (a [=holder=] or
[=verifier=]) is not willing to adhere to the specified terms of use, then
they do so on their own responsibility and might incur legal liability if they
violate the stated terms of use. Each `termsOfUse` value MUST specify
its [=type=], for example, `IssuerPolicy`, and MAY specify its
instance `id`. The precise contents of each term of use is determined
by the specific `termsOfUse` [=type=] definition.
          </dd>
        </dl>

        <pre class="example nohighlight"
          title="Usage of the termsOfUse property by an issuer">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "urn:did:123456",
  "type": [
    "VerifiableCredential",
    "EbsiTermsOfUseExample"
  ],
  "issuer": "did:ebsi:zz7XsC9ixAXuZecoD9sZEM1",
  "validFrom": "2021-11-01T00:00:00Z",
  "validUntil": "2021-10-30T00:00:00Z",
  "credentialSubject": {
    "id": "did:key:z2dmzD81cgPx8Vki7JbuuMmFYrWPgYoytykUZ3eyqht1j9KbrDt4zxXoDrBWYFiATYZ8G9JMeEXC7Kki24fbTwtsJbGe5qcbkYFunSzcDokMRmj8UJ1PbdCGh33mf97K3To89bMzd15qrYq3VkDztoZqfmujkJVpvTbqoXWXqxmzNDbvMJ",
    "personalIdentifier": "IT/DE/1234",
    "familyName": "Castafiori",
    "firstName": "Bianca",
    "dateOfBirth": "1930-10-01"
  },
  "credentialSchema": {
    "id": "https://api-test.ebsi.eu/trusted-schemas-registry/v2/schemas/z3MgUFUkb722uq4x3dv5yAJmnNmzDFeK5UC8x83QoeLJM",
    "type": "JsonSchema"
  },
  "termsOfUse": {
    "id": "https://api-test.ebsi.eu/trusted-issuers-registry/v4/issuers/did:ebsi:zz7XsC9ixAXuZecoD9sZEM1/attributes/7201d95fef05f72667f5454c2192da2aa30d9e052eeddea7651b47718d6f31b0",
    "type": "IssuanceCertificate"
  }
}
        </pre>

        <p>
In the example above, the [=issuer=] is asserting that as a European
Blockchain Services Infrastructure (EBSI) accredited issuer, it complies with the EBSI
policies as an accredited issuer and is registered in the EBSI register of trusted issuers.
The `termsOfUse` [=id=] can be resolved by the [=verifier=] to confirm
that the [=issuer=] has been issued an accreditation VC (in JWT format)
by a trusted issuer higher in the EBSI trust chain [?EBSI].
        </p>

        <pre class="example nohighlight" title="Usage of the termsOfUse property by a holder">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2",
    {
        "@protected": true,
        "VerifiablePresentationTermsOfUseExtension": {
          "@id": "https://www.w3.org/2018/credentials/examples#VerifiablePresentationExtension",
          "@context": {
            "@protected": true,
            "termsOfUse": {
              "@id": "https://www.w3.org/2018/credentials#termsOfUse",
              "@type": "@id"
            }
          }
        }
    }
  ],
  "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
  "type": ["VerifiablePresentation"],
  "verifiableCredential": [{
    "@context": [
      "https://www.w3.org/ns/credentials/v2",
      "https://www.w3.org/ns/credentials/examples/v2"
    ],
    "id": "http://university.example/credentials/3732",
    "type": ["VerifiableCredential", "ExampleDegreeCredential"],
    "issuer": "https://university.example/issuers/14",
    "validFrom": "2010-01-01T19:23:24Z",
    "credentialSubject": {
      "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "degree": {
        "type": "ExampleBachelorDegree",
        "name": "Bachelor of Science and Arts"
      }
    }
  }],
  <span class="highlight">"termsOfUse": [{
    "type": "HolderPolicy",
    "id": "http://example.com/policies/credential/6",
    "profile": "http://example.com/profiles/credential",
    "prohibition": [{
      "assigner": "did:example:ebfeb1f712ebc6f1c276e12ec21",
      "assignee": "https://wineonline.example.org/",
      "target": "http://university.example/credentials/3732",
      "action": ["3rdPartyCorrelation"]
    }]
  }]</span>
}
        </pre>

        <p>
In the example above, the [=holder=] (the `assigner`), who is
also the [=subject=], expressed a term of use prohibiting the [=verifier=]
(the `assignee`, `https://wineonline.example.org`) from
using the information provided to correlate the [=holder=] or [=subject=]
using a third-party service. If the [=verifier=] were to use a third-party
service for correlation, they would violate the terms under which the
[=holder=] created the [=presentation=].
        </p>

        <p>
This feature is also expected to be used by government-issued
[=verifiable credentials=] to instruct digital wallets to limit their use to
similar government organizations in an attempt to protect citizens from
unexpected usage of sensitive data. Similarly, some
[=verifiable credentials=] issued by private industry are expected to limit
usage to within departments inside the organization, or during business hours.
Implementers are urged to read more about this rapidly evolving feature in the
appropriate section of the Verifiable Credentials Implementation Guidelines
[[?VC-IMP-GUIDE]] document.
        </p>

      </section>

      <section>
        <h3>Evidence</h3>

        <p class="issue" data-number="1303" title="(AT RISK) Feature depends on demonstration of independent implementations">
This feature is at risk and will be removed from the specification if at least
two independent, interoperable implementations are not demonstrated for a
single extension type by the end of the Candidate Recommendation Phase. If
this feature is removed, the property will be included in Section
<a href="#reserved-extension-points"></a>, in anticipation of future
implementation and inclusion in the specification.
        </p>

        <p>
Evidence can be included by an [=issuer=] to provide the [=verifier=] with
additional supporting information in a [=verifiable credential=]. This could
be used by the [=verifier=] to establish the confidence with which it relies
on the claims in the [=verifiable credential=].
        </p>
        <p>
For example, an [=issuer=] could check physical documentation provided by the
[=subject=] or perform a set of background checks before issuing the
[=credential=]. In certain scenarios, this information is useful to the
[=verifier=] when determining the risk associated with relying on a given
[=credential=].
        </p>

        <p>
This specification defines the `evidence` [=property=] for
expressing evidence information.
        </p>

        <dl>
          <dt><dfn id="defn-evidence" class="export">evidence</dfn></dt>
          <dd>
The value of the `evidence` [=property=] MUST be one or more
evidence schemes providing enough information for a [=verifier=] to determine
whether the evidence gathered by the [=issuer=] meets its confidence
requirements for relying on the [=credential=]. Each evidence scheme is
identified by its [=type=]. The `id` [=property=] is optional,
but if present, SHOULD contain a URL that points to where more information about
this instance of evidence can be found. The precise content of each evidence
scheme is determined by the specific `evidence` [=type=]
definition.
          </dd>
        </dl>

        <p class="note">
For information about how attachments and references to [=credentials=] and
non-credential data might be supported by the specification, see the
Verifiable Credentials Implementation Guidelines [[VC-IMP-GUIDE]] document.
        </p>

        <pre class="example nohighlight"
          title="Usage of the evidence property">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/3732",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  },
  <span class="highlight">"evidence": {
    "id": "https://university.example/evidence/f2aeec97-fc0d-42bf-8ca7-0548192d4231",
    "type": ["DocumentVerification"],
    "verifier": "https://university.example/issuers/14",
    "evidenceDocument": "DriversLicense",
    "subjectPresence": "Physical",
    "documentPresence": "Physical",
    "licenseNumber": "123AB4567"
  }</span>
}
        </pre>

        <p class="note">
In this `evidence` example, the [=issuer=] is asserting that they
physically matched the [=subject=] of the [=credential=] to a physical
copy of a driver's license with the stated license number. This driver's license
was used in the issuance process to verify that "Example University" verified
the subject before issuance of the credential and how they did so (physical
verification).
        </p>

        <p class="note">
The `evidence` [=property=] provides different and complementary
information to the `proof` [=property=]. The `evidence`
[=property=] is used to express supporting information, such as documentary
evidence, related to the integrity of the [=verifiable credential=]. In
contrast, the `proof` [=property=] is used to express
machine-verifiable mathematical proofs related to the authenticity of the
[=issuer=] and integrity of the [=verifiable credential=]. For more
information about the `proof` [=property=], see Section
<a href="#proofs-signatures"></a>.
        </p>

      </section>

      <section>
        <h3>Zero-Knowledge Proofs</h3>

        <p>
Zero-knowledge proofs are cryptographic methods which enable a user to prove
knowledge of a value without disclosing the actual value. This data model
supports being secured with the use of zero-knowledge proof mechanisms.
        </p>
        <p>
Some capabilities that are compatible with [=verifiable credentials=] which
are made possible by zero-knowledge proof mechanisms:
        </p>
        <ul>
          <li>
Selective disclosure of the properties in a [=verifiable credential=] by the
[=holder=] to a [=verifier=]. This allows a [=holder=] to provide a
[=verifier=] with precisely the information they need and nothing more.
This also enables the production of a derived [=verifiable credential=] that
is formatted according to the [=verifier's=] data schema without needing to
involve the [=issuer=] during presentation. This provides a great deal of
flexibility for [=holders=] to use their issued
[=verifiable credentials=].
          </li>
          <li>
Blinding of the signature value that is shared with a [=verifier=]. Blinded
signatures allow for unlinkable proofs, which remove a common source of
[=holder=] correlation during multiple presentations to one or more
[=verifiers=]. This allows a [=holder=] to share a different signature
value with each presentation, which in turn reduces the amount of data shared.
          </li>
          <li>
Privacy preserving identification of the [=holder=] and/or [=subject=].
This allows a [=holder=] to prove that a [=credential=] was issued to
them, or a [=subject=] to prove that a [=credential=] was issued about
them, without sharing an identifier. This also reduces the amount of data
necessary to be shared. This capability can also be used to combine multiple
[=verifiable credentials=] from multiple [=issuers=] into a single
[=verifiable presentation=] without revealing [=verifiable credential=] or
[=subject=] identifiers to the [=verifier=].
          </li>
        </ul>
        <p>
Not all capabilities are supported in all zero-knowledge proof mechanisms.
Specific details about the capabilities and techniques provided by a particular
zero knowledge proof mechanism, along with any normative requirements for using
them with [=verifiable credentials=], would be found in a specification for
securing [=verifiable credentials=] with that zero-knowledge proof mechanism.
        </p>
        <p>
We note that in most instances, for [=holder=] to make use of zero knowledge
mechanisms with [=verifiable credentials=] requires an [=issuer=] to
secure the [=verifiable credential=] in a manner that supports these
capabilities.
        </p>
        <p>
When a [=holder=] has selectively disclosed a portion of a
[=verifiable credential=], it is important that the [=verifier=] check
whether the information provided in the derived [=verifiable credential=] is
compatible with the schema in the `credentialSchema`
[=property=] provided by the [=issuer=]. It is also possible for the
[=verifier=] to provide a schema to the [=holder=] as part of a request
for the [=holder=]'s data, and for the [=verifier=] to ensure that the
derived [=verifiable credential=] is compatible with that schema as well. We
do not define such a request schema in this specification, but an example of one
method for doing so is [[?PRES-EX]].
        </p>
        <p class="note">
`credentialSchema` implementers are encouraged to consider the
implications of selective disclosure credentials and provide guidance for
processing depending on the construction. If a schema is not formed with
selective disclosure in mind, then validation is likely to fail.
        </p>
        <p>
The diagram below highlights how the data model might be used to issue and
present [=verifiable credentials=] in zero-knowledge.
        </p>
        <p class="issue">
Examples of leveraging <a href="https://w3c.github.io/vc-di-bbs/">vc-di-bbs</a>,
will be added here in the future, or this section will be removed.
        </p>

        <figure>
          <img style="margin: auto; display: block; width: 75%;"
            src="diagrams/zkp-cred-pres.svg" alt="Verifiable
            Credential 1 and Verifiable Credential 2 on the left map
            to Derived Credential 1 and Derived Credential 2 inside a
            Presentation on the right.  Verifiable Credential 1
            contains Context, Type, ID, Issuer, Issue Date, Expiration
            Date, CredentialSubject, and Proof, where
            CredentialSubject contains GivenName, FamilyName, and
            Birthdate and Proof contains Signature, Proof of
            Correctness, and Attributes.  Verifiable Credential 2
            contains Context, Type, ID, Issuer, Issue Date, Expiration
            Date, CredentialSubject, and Proof, where
            CredentialSubject contains University, which contains
            Department, which contains DegreeAwarded, and Proof contains Signature, Proof of
            Correctness, and Attributes.  The Presentation diagram on
            the right contains Context, Type, ID,
            VerifiableCredential, and Proof, where
            VerifiableCredential contains Derived Credential 1 and
            Derived Credential 2 and Proof contains Common Link
            Secret.  Derived Credential 1 contains Context, Type, ID,
            Issuer, Issue Date, CredentialSubject, and Proof, where
            CredentialSubject contains AgeOver18 and Proof contains
            Knowledge of Signature.  Derived Credential 2 contains
            Context, Type, ID, Issuer, Issue Date, CredentialSubject,
            and Proof, where CredentialSubject contains Degree and
            Proof contains Knowledge of Signature.  A line links
            Birthdate in Verifiable Credential 1 to AgeOver18 in
            Derived Credential 1.  A line links DegreeAwarded in
            Verifiable Credential 2 to Degree in Derived Credential 2.">
          <figcaption style="text-align: center;">
A visual example of the relationship between credentials and derived
credentials in a ZKP [=presentation=].
          </figcaption>
        </figure>

        <p>
The following guideline is provided for authors who create
<a href="#securing-mechanisms">securing mechanisms</a>
specifications that provide unlinkability:
        </p>

        <ul>
          <li>
Unlinkable securing mechanisms MUST NOT be designed in such a way that they
leak information that would enable the [=verifier=] to correlate a
[=holder=] across multiple [=verifiable presentations=] to different
[=verifiers=].
          </li>
        </ul>

      </section>

      <section class="informative">
        <h3>Authorization</h3>

        <p>
[=Verifiable credentials=] are intended as a means of reliably identifying
[=subjects=]. While it is recognized that Role Based Access Controls (RBACs)
and Attribute Based Access Controls (ABACs) rely on this identification as a
means of authorizing [=subjects=] to access resources, this specification
does not provide a complete solution for RBAC or ABAC. Authorization is not an
appropriate use for this specification without an accompanying authorization
framework.
        </p>

        <p>
The Working Group did consider authorization use cases during the creation of
this specification and is pursuing that work as an architectural layer built
on top of this specification.
        </p>
      </section>

      <section class="normative">
        <h3>Reserved Extension Points</h3>

        <p>
This specification reserves a number of [=properties=] to serve as possible
extension points. While some implementers signaled interest in these properties,
their inclusion in this specification was considered to be premature; these
extension points might be more formally defined in future versions of this
specification. It is important to note that these properties are not defined by
this specification and implementers are cautioned that usage of these properties
is considered experimental.
        </p>
        <p>
Implementers MAY use these properties, but SHOULD expect them and/or
their meanings to change during the process to normatively specify them.
Implementers SHOULD NOT use these properties without a publicly disclosed
specification describing their implementation.
        </p>

        <p>
In order to avoid collisions regarding how the following properties are used,
implementations MUST specify a `type` property in the value associated with the
reserved property. For more information related to adding `type` information,
see Section <a href="#types"></a>.
        </p>
        <p class="issue" title="Extension points under consideration by the Working Group">
The working group is discussing if additional extension points
will be reserved in <a href="https://www.w3.org/ns/credentials/v2">https://www.w3.org/ns/credentials/v2</a>.
<br/><br/>
The working group currently plans to only reserve extension points that
have at least a draft specification that is being incubated in a community group.
        </p>

        <table class="simple">
          <thead>
            <tr>
              <th>Reserved&nbsp;Property</th>
              <th>Description</th>
            </tr>
          </thead>

          <tbody>
            <tr>
              <td>`confidenceMethod`</td>
              <td>
A property used for specifying one or more methods that a verifier might use to
increase their confidence that the value of an attribute in or of a verifiable
credential or verifiable presentation is accurate, including but not limited to
attributes such as `initialRecipient` (a/k/a `issuee`), `presenter`,
`authorizedPresenter`, `holder`, etc. The associated vocabulary URL MUST be
`https://www.w3.org/2018/credentials#confidenceMethod`.
                <p class="issue" title="(AT RISK) Reservation depends on implementations">
This property reservation might be deleted in favor of an existing section
in the specification if at least one specification with two independent
implementations are demonstrated by the end of the Candidate Recommendation
Phase. If that does not occur, this reservation will remain, but the existing
section in the specification will be removed.
See <a href="https://w3c-ccg.github.io/confidence-method-spec/">Verifiable Credential Confidence Methods</a>.
                </p>
              </td>
            </tr>
            <tr>
              <td>`evidence`</td>
              <td>
A property used for specifying the evidence that was presented in order to
issue the credential. The associated vocabulary URL MUST be
`https://www.w3.org/2018/credentials#evidence`.
                <p class="issue" title="(AT RISK) Reservation depends on implementations">
This property reservation might be deleted in favor of an existing section
in the specification if at least one specification with two independent
implementations are demonstrated by the end of the Candidate Recommendation
Phase. If that does not occur, this reservation will remain, but the existing
section in the specification will be removed.
                </p>
              </td>
            </tr>
            <tr>
              <td>`refreshService`</td>
              <td>
A property used for specifying how a credential can be refreshed. The
associated vocabulary URL MUST be
`https://www.w3.org/2018/credentials#refreshService`.
                <p class="issue" title="(AT RISK) Reservation depends on implementations">
This property reservation might be deleted in favor of an existing section
in the specification if at least one specification with two independent
implementations are demonstrated by the end of the Candidate Recommendation
Phase. If that does not occur, this reservation will remain, but the existing
section in the specification will be removed.
                </p>
              </td>
            </tr>
            <tr>
              <td>`renderMethod`</td>
              <td>
A property used for specifying one or more methods to render a credential into a visual,
auditory, or haptic format. The associated vocabulary URL MUST be
`https://www.w3.org/2018/credentials#renderMethod`.
                <p class="issue" title="(AT RISK) Reservation depends on implementations">
This reserved property is at risk and will be removed from the
specification if at least one specification with two independent implementations
are not demonstrated by the end of the Candidate Recommendation Phase.
See <a href="https://w3c-ccg.github.io/vc-render-method/">Verifiable Credential Rendering Methods</a>.
                </p>
              </td>
            </tr>
            <tr>
              <td>`termsOfUse`</td>
              <td>
A property used for specifying the terms of use for a credential. The associated
vocabulary URL MUST be `https://www.w3.org/2018/credentials#termsOfUse`.
                <p class="issue" title="(AT RISK) Reservation depends on implementations">
This property reservation might be deleted in favor of an existing section
in the specification if at least one specification with two independent
implementations are demonstrated by the end of the Candidate Recommendation
Phase. If that does not occur, this reservation will remain, but the existing
section in the specification will be removed.
                </p>
              </td>
            </tr>
          </tbody>
        </table>


        <p>
An unofficial list of specifications that are associated with the extension
points defined in this specification, as well as the reserved extension points
defined in this section, can be found in the Verifiable Credentials
Specifications Directory [[?VC-SPECS]]. Items in the directory that refer to
reserved extension points SHOULD be treated as experimental.
        </p>

      </section>

      <section class="normative">
        <h3>Ecosystem Compatibility</h3>

        <p>
There are a number of digital credential formats that do not natively use the
data model provided in this document, but are aligned with a number of concepts
in this specification. At the time of publication, examples of these digital
credential formats include
<a href="https://www.rfc-editor.org/rfc/rfc7519.html">
JSON Web Tokens</a> (JWTs),
<a href="https://www.rfc-editor.org/rfc/rfc8392.html">
CBOR Web Tokens</a> (CWTs),
<a href="https://www.iso.org/standard/69084.html">ISO-18013-5:2021</a>
(mDLs),
<a href="https://hyperledger.github.io/anoncreds-spec/">
AnonCreds</a>,
<a href="https://datatracker.ietf.org/doc/draft-mcnally-envelope/">
Gordian Envelopes</a>, and
<a href="https://datatracker.ietf.org/doc/draft-ssmith-acdc/">
Authentic Chained Data Containers</a> (ACDCs).
        </p>

        <p>
If conceptually aligned digital credential formats can be transformed into a
[=conforming document=] according to the rules provided in this section, they
are considered <em>"compatible with the W3C Verifiable Credentials
ecosystem"</em>. Specifications that describe how to perform transformations
that enable compatibility with the Verifiable Credentials ecosystem:
        </p>

        <ul>
          <li>
MUST identify whether the transformation to this data model is one-way-only or
round-trippable.
          </li>
          <li>
MUST preserve the `@context` values when performing round-trippable
transformation.
          </li>
          <li>
MUST result in a [=conforming document=] when transforming to the data
model described by this specification.
          </li>
          <li>
MUST specify a registered media type for the input document.
          </li>
          <li>
SHOULD provide a test suite that demonstrates that the specified transformation
algorithm to the data model in this specification results in
a [=conforming document=].
          </li>
          <li>
SHOULD ensure that all semantics utilized in the transformed
[=conforming document=] follow best practices for Linked Data. See
Section <a href="#getting-started"></a>, Section
<a href="#extensibility"></a>, and Linked Data Best Practices [[?LD-BP]]
for additional guidance.
          </li>
        </ul>

        <p class="note" title="What constitutes a verifiable credential?">
Readers are advised that a digital credential is only considered compatible with
the W3C Verifiable Credentials ecosystem if it is a [=conforming document=]
and it utilizes at least one securing mechanism, as described by their
respective requirements in this specification. While some communities might call
some digital credential formats that are not [=conforming documents=]
"verifiable credentials", doing so does NOT make that digital credential
compliant to this specification.
        </p>

      </section>

      <section>
        <h3>Verifiable Credential Graphs</h3>

        <p>
When expressing [=verifiable credentials=] (for example in a
[=presentation=]), it is important to ensure that data in one <a>verifiable
credential</a> is not mistaken to be the same data in another <a>verifiable
credential</a>. For example, if one has two [=verifiable credentials=], each
containing an object of the following form: `{"type": "Person", "name": "Jane
Doe"}`, it is not possible to tell if one object is describing the same person
as the other object. In other words, merging data between two <a>verifiable
credentials</a> without confirming that they are discussing the same entities
and/or properties, can lead to a corrupted data set.
        </p>

        <p>
To ensure that data from different [=verifiable credentials=] are not
accidentally co-mingled, the concept of a <dfn class="export">verifiable
credential graph</dfn> is used to encapsulate each [=verifiable credential=].
For simple [=verifiable credentials=], i.e., when the JSON-LD document
contains a single credential with, possibly, associated proofs, this graph is
the [=default graph=]. For [=presentations=], each value associated with
the `verifiableCredential` property of the [=presentation=] is a separate
[=named graph=] of type <dfn class="export">VerifiableCredentialGraph</dfn>
which contains a single [=verifiable credential=] or an
<a href="#enveloped-verifiable-credentials">enveloped verifiable credential</a>.
        </p>
        <p>
Using these [=graphs=] has a concrete effect when performing JSON-LD
processing, which properly separates graph node identifiers in one graph from
those in another graph. Implementers that limit their inputs to
application-specific JSON-LD documents will also need to keep this in mind if
they merge data from one [=verifiable credential=] with data from another,
such as when the `credentialSubject.id` is the same in both <a>verifiable
credentials</a>, but the object might contain objects of the "Jane Doe" form
described in the previous paragraph. It is important to not merge objects that
seem to have similar properties but do not contain an `id` property that uses a
global identifier, such as a URL.
        </p>
      </section>

      <section>
        <h3>Securing Mechanism Specifications</h3>

        <p>
As described in Section <a href="#securing-mechanisms"></a>, there are
multiple strategies that an implementer can use when securing a
<a>conforming document</a>. In order to maximize utility and interoperability,
specification authors that desire to author new ways of securing
<a>conforming documents</a> are provided with the guidance in this section.
        </p>

        <p>
Securing mechanism specifications MUST document normative algorithms that
provide content integrity protection for [=conforming documents=]. The
algorithms MAY be general in nature and MAY be used to secure data other than
[=conforming documents=].
        </p>

        <p>
Securing mechanism specifications MUST provide a verification mechanism that
returns only the information in the [=conforming document=] that has been
secured, without any securing mechanism information included, such as `proof` or
JOSE/COSE metadata. Specifications MAY provide additional mechanisms to convey
other information that might be helpful (for example, during validation or for
debugging purposes), such as securing mechanism metadata. A securing mechanism's
verification algorithm MUST provide an interface that receives a sequence of
bytes ([=byte sequence=] |inputBytes|) or a document ([=map=] |inputDocument|)
and a media type ([=string=] |inputMediaType|) as inputs and returns a
verification result with at least the following [=struct/items=]:
        </p>

        <dl>
          <dt>[=boolean=] |status|</dt>
          <dd>
A verification status whose value is `true` if the verification succeeded and
`false` if it did not.
          </dd>
          <dt>[=map=] |document|</dt>
          <dd>
A document that only contains information that was successfully secured.
          </dd>
          <dt>[=string=] |mediaType|</dt>
          <dd>
A media type as defined in [[RFC6838]].
          </dd>
          <dt>[=string=] |controller|</dt>
          <dd>
A verification method controller as defined in [[VC-DATA-INTEGRITY]] or
[[VC-JOSE-COSE]].
          </dd>
          <dt>[=map=] |controllerDocument|</dt>
          <dd>
A controller document as defined in [[VC-DATA-INTEGRITY]] or
[[VC-JOSE-COSE]].
          </dd>
        </dl>

        <p>
Securing mechanism specifications SHOULD provide integrity protection for any
information referenced by a URL that is critical to validation. Mechanisms that
can achieve this protection are discussed in Section
<a href="#integrity-of-related-resources"></a> and Section
<a href="#base-context"></a>.
        </p>

        <p>
Securing mechanism specifications SHOULD register the securing mechanism in the
<a data-cite="?VC-SPECS#securing-mechanisms">Securing Mechanisms</a> section
of the [[[?VC-SPECS]]] [[?VC-SPECS]].
        </p>

        <p class="note"
           title="Choice of securing mechanism is use-case dependent">
There are multiple acceptable securing mechanisms, and this specification does
not mandate any particular securing mechanism for use with
[=verifiable credentials=] or [=verifiable presentations=].
The Working Group that produced this specification did standardize two
securing mechanism options, which are:
[[[VC-DATA-INTEGRITY]]] [[VC-DATA-INTEGRITY]] and [[[VC-JOSE-COSE]]]
[[VC-JOSE-COSE]]. Other securing mechanisms that are known to the community
can be found in the
<a data-cite="?VC-SPECS#securing-mechanisms">Securing Mechanisms</a> section
of the [[[?VC-SPECS]]] [[?VC-SPECS]].
        </p>

        <p class="issue atrisk"
           title="Controller document reference might change">
The Working Group is currently attempting to align the definitions of a
controller document between [[[?DID-CORE]]], [[[VC-DATA-INTEGRITY]]], and
[[[VC-JOSE-COSE]]]. The goal is to have one specification that each of the
previously stated specifications, and this specification, can reference for
the normative statements related to controller documents. The normative
references to controller documents are expected to change during the
Candidate Recommendation phase.
        </p>

      </section>

    </section>

    <section>
      <h2>Syntaxes</h2>

      <p>
The data model as described in Sections
<a href="#core-data-model"></a>, <a href="#basic-concepts"></a>, and
<a href="#advanced-concepts"></a> is the canonical structural representation of
a [=verifiable credential=] or [=verifiable presentation=]. All
serializations are representations of that data model in a specific format. This
section specifies how the data model is realized in JSON-LD for
`application/vc+ld+json`, the base media type for Verifiable Credentials.
Although syntactic mappings are only provided for JSON-LD, applications and
services can use any other data representation syntax (such as XML, YAML, or
CBOR) that is capable of being mapped back to `application/vc+ld+json`. As the
[=verification=] and [=validation=] requirements are defined in terms of
the data model, all serialization syntaxes have to be deterministically
translated to the data model for processing, [=validation=], or comparison.
      </p>

      <p>
The expected arity of the property values in this specification, and the
resulting datatype which holds those values, can vary depending on the property.
If present, the following properties are represented as a single value:
      </p>

      <ul>
        <li>
`id` [=property=]
        </li>
        <li>
`issuer` [=property=]
        </li>
        <li>
`validFrom` [=property=]
        </li>
        <li>
`validUntil` [=property=].
        </li>
      </ul>

      <p>
All other properties, if present, are represented as either a single value
or an array of values.
      </p>

      <section>
        <h3>JSON-LD</h3>

        <p>
[[!JSON-LD]] is a JSON-based format used to serialize
<a href="https://www.w3.org/TR/ld-glossary/#linked-data">Linked Data</a>. The
syntax is designed to easily integrate into deployed systems already using JSON,
and provides a smooth upgrade path from JSON to [[!JSON-LD]]. It is primarily
intended to be a way to use Linked Data in Web-based programming environments,
to build interoperable Web services, and to store Linked Data in JSON-based
storage engines.
        </p>

        <p>
[[!JSON-LD]] is useful when extending the data model described in this
specification. Instances of the data model are encoded in JSON-LD compacted
form [[!JSON-LD]] and include the `@context` [=property=]. The
<a href="https://www.w3.org/TR/json-ld/#the-context">JSON-LD context</a>
is described in detail in the [[!JSON-LD]] specification and its use is
elaborated on in Section <a href="#contexts"></a> and
Section <a href="#extensibility"></a>.
        </p>

        <p>
Multiple contexts MAY be used or combined to express any arbitrary information
about [=verifiable credentials=] in idiomatic JSON. The
<a href="https://www.w3.org/TR/json-ld/#the-context">JSON-LD context</a>,
available at `https://www.w3.org/ns/credentials/v2`, is a static
document that is never updated and can therefore be downloaded and cached client
side. The associated vocabulary document for the Verifiable Credentials Data
Model is available at `https://www.w3.org/2018/credentials`.
        </p>

        <p>
This specification restricts the usage of JSON-LD representations of
the data model. JSON-LD <a
href="https://www.w3.org/TR/json-ld/#compacted-document-form">compacted document
form</a> MUST be utilized for all representations of the data model in the
base media type, `application/vc+ld+json`.
        </p>

        <p>
As elaborated upon in Section
<a href="#credential-type-specific-processing"></a>, some software applications
might not perform generalized JSON-LD processing. Authors of <a>conforming
documents</a> are advised that interoperability might be reduced if JSON-LD
keywords in the `@context` value are used to globally affect values in a
[=verifiable credential=] or [=verifiable presentation=], such as by
globally setting the `@base` keyword. For example, globally setting these values
might trigger a failure in a mis-implemented JSON Schema check on the `@context`
value in an implementation that is performing <a>credential type-specific
processing</a> and not expecting the `@base` value to be expressed in the
`@context` value.
        </p>

        <p>
In order to increase interoperability, [=conforming document=] authors are
urged to not use JSON-LD features that are not easily detected when performing
[=credential type-specific processing=]. These features include:
        </p>

        <ul>
          <li>
Use of JSON-LD keywords in the `@context` value that globally modify document
value processing, such as global settings of `@base`
          </li>
          <li>
In-line declaration of JSON-LD contexts in the `@context` property.
          </li>
          <li>
Use of full URLs for JSON-LD terms and types (e.g.,
`https://www.w3.org/2018/credentials#VerifiableCredential` or
`https://vocab.example/myvocab#SomeNewType`) instead of the short forms of
any such values (e.g., `VerifiableCredential` or `SomeNewType`) that are
either explicitly defined as JSON-LD `@context` mappings (e.g.,
`https://www.w3.org/ns/credentials/v2`) or are implicitly defined via the
`@vocab` feature that applies to all undefined terms.
          </li>
       </ul>

        </p>

        <section>
          <h3>Syntactic Sugar</h3>

          <p>
In general, the data model and syntaxes described in this document are
designed such that developers can copy and paste examples to incorporate
[=verifiable credentials=] into their software systems. The design goal of
this approach is to provide a low barrier to entry while still ensuring global
interoperability between a heterogeneous set of software systems. This section
describes some of these approaches, which will likely go unnoticed by most
developers, but whose details will be of interest to implementers. The most
noteworthy syntactic sugars provided by [[!JSON-LD]] are:
          </p>

          <ul>
            <li>
The `@id` and `@type` keywords are aliased to
`id` and `type` respectively, enabling developers to use
this specification as idiomatic JSON.
            </li>
            <li>
Data types, such as integers, dates, units of measure, and URLs, are
automatically typed to provide stronger type guarantees for use cases that
require them.
            </li>
            <li>
The `verifiableCredential` and `proof` [=properties=]
are defined as
<a href="https://www.w3.org/TR/json-ld11/#graph-containers">JSON-LD 1.1 graph
containers</a>. This means the creation of [=named graphs=] used to isolate
sets of data asserted by different entities. This ensures, for example, proper
cryptographic separation between the data graph provided by each [=issuer=]
and the one provided by the [=holder=] presenting the <a>verifiable
credential</a> to ensure the provenance of the information for each graph is
preserved.
            </li>
            <li>
The `@protected` properties feature of [[!JSON-LD]] 1.1 is used to
ensure that terms defined by this specification cannot be overridden. This means
that as long as the same `@context` declaration is made at the top of
a [=verifiable credential=] or [=verifiable presentation=],
interoperability is guaranteed for all terms understood by users of the data
model whether or not they use a [[!JSON-LD]] processor.
            </li>
          </ul>
        </section>
        <section>
          <h3>Lists and Arrays</h3>
          <p>
Lists, arrays, and even lists of lists, are possible when using [[JSON-LD]] 1.1.
We encourage those who want RDF semantics in use
cases requiring lists and arrays to follow the guidance on
<a href="https://www.w3.org/TR/json-ld11/#lists">lists in JSON-LD 1.1</a>.
          </p>
          <p>
In general, a JSON array is ordered, while a JSON-LD array is not ordered unless
that array uses the `@list` keyword.
          </p>
          <p class="note">
While it is possible to use this data model without any JSON-LD processing,
those who do so and make use of arrays need to be aware that unless the above
guidance is followed, the order of items in an array cannot be guaranteed in
JSON-LD. This might lead to unexpected behavior.
          </p>
          <p>
If JSON structure or ordering is important to your application,
we recommend you mark such elements as `@json` via an `@context`.
          </p>
          <pre class="example" title="A @context file that defines a matrix as an embedded JSON data structure">
{
  "@context":
    {
      "matrix": {
        "@id": "https://website.example/vocabulary#matrix",
        "@type": "@json"
      }
    }
}
          </pre>
          <pre class="example" title="A verifiable credential with an embedded JSON data structure">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2",
    "https://website.example/matrix/v1"
  ],
  "id": "http://university.example/credentials/1872",
  "type": [
    "VerifiableCredential",
    "ExampleMatrixCredential"
  ],
  "issuer": "https://university.example/issuers/565049",
  "validFrom": "2010-01-01T19:23:24Z",
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "matrix": [
      [1,2,3,4,5,6,7,8,9,10,11,12],
      [1,1,1,1,1,1,1,1,0,0,0,0],
      [0,0,1,1,1,1,1,1,1,0,0,0]
    ]
  }
}
          </pre>
        </section>
      </section>
      <section>
        <h3>Media Types</h3>

        <p>
Media types, as defined in [[RFC6838]], identify the syntax used to express a
[=verifiable credential=] as well as other useful processing guidelines.
        </p>
        <p>
Syntaxes used to express the data model in this specification SHOULD be
identified by a media type, and conventions outlined in this section SHOULD be
followed when defining or using media types with [=verifiable credentials=].
        </p>
        <p>
There are two media types associated with the core data model, which are
listed in the Section <a href="#iana-considerations"></a>:
`application/vc+ld+json` and `application/vp+ld+json`.
        </p>
        <p>
The `application/vc+ld+json` and `application/vp+ld+json` media types do not
imply any particular securing mechanism, but are intended to be used in
conjunction with securing mechanisms. A securing mechanism needs to be applied
to protect the integrity of these media types. Do not assume security of content
regardless of the media type used to communicate it.
        </p>

        <section class="informative">
          <h3>Media Type Precision</h3>

          <p>
At times, developers or systems might use lower precision media types to convey
[=verifiable credentials=] or [=verifiable presentations=]. Some of the
reasons for use of lower precision media types include:
          </p>

          <ul>
            <li>
A web server defaults to `text/plain` or `application/octet-stream` when a file
extension is not available and it cannot determine the media type.
            </li>
            <li>
A developer adds a file extension that leads to a media type that is less
specific than the content of the file. For example, `.json` could result in a
media type of `application/json` and `.jsonld` might result in a media type of
`application/ld+json`.
            </li>
            <li>
A protocol requires a less precise media type for a particular transaction; for
example, `application/json` instead of `application/vp+ld+json`,
            </li>
          </ul>

          <p>
Implementers are urged to not raise errors when it is possible to determine the
intended media type from a payload, provided that the media type used is
acceptable in the given protocol. For example, if an application only accepts
payloads that conform to the rules associated with the `application/vc+ld+json`
media type, but the payload is tagged with `application/json` or
`application/ld+json` instead, the application might perform the following
steps to determine whether the payload also conforms to the higher precision
media type:
          </p>

          <ol>
            <li>
Parse the payload as a JSON document.
            </li>
            <li>
Ensure that the first element of the `@context` field matches
`https://www.w3.org/2018/credentials/v2`.
            </li>
            <li>
Assume an `application/vp+ld+json` media type if the JSON document contains a
top-level `type` field containing a `VerifiablePresentation` element. Additional
subsequent checks are still expected to be performed (according to this
specification) to ensure the payload expresses a conformant Verifiable
Presentation.
            </li>
            <li>
Assume an `application/vc+ld+json` media type if the JSON document contains a
top-level `type` field containing a `VerifiableCredential` element. Additional
subsequent checks are still expected to be performed (according to this
specification) to ensure the payload expresses a conformant Verifiable
Credential.
            </li>
          </ol>

          <p>
Whenever possible, implementers are advised to use the most precise (the highest
precision) media type for all payloads defined by this specification.
Implementers are also advised to recognize that a payload tagged with a lower
precision media type does not mean that the payload does not meet the rules
necessary to tag it with a higher precision type. Similarly, a payload tagged
with a higher precision media type does not mean that the payload will meet the
requirements associated with the media type. Receivers of payloads, regardless
of their associated media type, are expected to perform appropriate checks to
ensure that payloads conform with the requirements for their use in a given
system.
          </p>
        </section>
        <section class="informative">
          <h2>HTTP</h2>
          <p>
It is expected that HTTP endpoints will use the media types associated with
[=verifiable credentials=] and [=verifiable presentations=] in accept
headers and when indicating content types.
          </p>
          <p>
Nonetheless, HTTP servers might ignore the accept header and return another
content type, or return an error code such as
<a data-cite="RFC7231#section-6.5.13">`415 Unsupported Media Type`</a>.
          </p>
        </section>

        <section class="informative">
          <h2>Credential Type-Specific Processing</h2>

          <p>
<dfn>General JSON-LD processing</dfn> is defined as a mechanism that utilizes a
JSON-LD software library to process a [=conforming document=] by performing
various <a data-cite="?JSON-LD11#forms-of-json-ld">transformations</a>.
<dfn>Credential type-specific processing</dfn> is defined as a lighter-weight
mechanism for processing [=conforming documents=], that doesn't require
a JSON-LD software library. Some consumers of [=verifiable credentials=]
only need to consume credentials with specific types. These consumers can use
credential-type-specific processing instead of generalized processing. Scenarios
where credential-type-specific processing can be desirable include, but are not
limited to, the following:
          </p>

          <ul>
            <li>
Before applying a securing mechanism to a [=conforming document=], or after
verifying a [=conforming document=] protected by a securing mechanism, to
ensure
<a href="https://csrc.nist.gov/glossary/term/data_integrity">data integrity</a>.
            </li>
            <li>
When performing JSON Schema validation, as described in Section
<a href="#data-schemas"></a>.
            </li>
            <li>
When serializing or deserializing [=verifiable credentials=] or
[=verifiable presentations=] into systems that store or index their contents.
            </li>
            <li>
When operating on [=verifiable credentials=] or <a>verifiable
presentations</a> in a software application, after verification or validation
is performed for securing mechanisms that require
[=general JSON-LD processing=].
            </li>
            <li>
When an application chooses to process the media type using the `+json`
structured media type suffix.
            </li>
          </ul>

          <p>
That is, [=credential type-specific processing=] is allowed as long as the
document being consumed or produced is a [=conforming document=]. If this
type of processing is desired, an implementer is advised to follow this rule:
          </p>

          <ul>
            <li>
Ensure that all values associated with a `@context` property are in the
expected order, the contents of the context files match known good
cryptographic hashes for each file, and domain experts have deemed that the
contents are appropriate for the intended use case.
            </li>
          </ul>

          <p>
Using static context files with a JSON Schema is one acceptable approach to
implementing the rule above. This can ensure proper term identification,
typing, and order, when performing [=credential type-specific processing=].
          </p>

          <p>
The rule above guarantees semantic interoperability between the two processing
mechanisms for mapping literal JSON keys to URIs via the `@context` mechanism.
While [=general JSON-LD processing=] can use previously unseen `@context`
values provided in its algorithms to verify that all terms are correctly
specified, implementations that perform <a>credential type-specific
processing</a> only accept specific `@context` values which the implementation
is engineered ahead of time to understand, resulting in the same semantics
without invoking any JSON-LD APIs. In other words, the context in which the data
exchange happens is explicitly stated for both processing mechanisms by using
`@context` in a way that leads to the same [=conforming document=] semantics.
          </p>

        </section>
      </section>

      <section>
        <h3>Proof Formats</h3>

        <p>
The data model described in this specification is designed to be proof format
agnostic. This specification does not normatively require any particular digital
proof or signature format. While the data model is the canonical representation
of a [=credential=] or [=presentation=], the proofing mechanisms for these
are often tied to the syntax used in the transmission of the document between
parties. As such, each proofing mechanism has to specify whether the
verification of the proof is calculated against the state of the document as
transmitted, against the possibly transformed data model, or against another
form. At the time of publication, at least two proof formats are being actively
utilized by implementers and the Working Group felt that documenting what these
proof formats are and how they are being used would be beneficial to
implementers. The sections detailing the current proof formats being actively
utilized to issue [=verifiable credentials=] are:
        </p>

        <ul>
          <li>
Verifiable Credentials using JOSE and COSE [[VC-JOSE-COSE]], and
          </li>
          <li>
Verifiable Credential Data Integrity [[VC-DATA-INTEGRITY]].
          </li>
        </ul>

      </section>
    </section>

    <section class="normative">
      <h2>Algorithms</h2>

      <p>
This section contains algorithms that can be used by implementations to perform
common operations, such as verification. Conformance requirements phrased as
algorithms utilize normative concepts from the [[[INFRA]]] [[INFRA]]. See the
section on <a data-cite="INFRA#conformance">Conformance</a> in the [[[INFRA]]]
for more guidance on implementation requirements.
      </p>

      <p class="issue atrisk" title="Issues need resolution before Candidate Recommendation">
There is one issue that is associated with this section that will need
to be resolved before the Working Group can enter the Candidate Recommendation
phase. This entire section is at risk until those issues are resolved.
      </p>

      <p class="issue" data-number="1377"></p>

      <p class="note" title="Implementers can include additional checks, warnings, and errors.">
Implementers are advised that the algorithms in this section contain the bare
minimum set of checks used by implementations to test conformance to this
specification. Implementations are expected to provide additional checks that
report helpful warnings for developers to help debug potential issues.
Similarly, implementations are likely to provide additional checks that
could result in new types of errors being reported in order to stop harmful
content. Any of these additional checks might be integrated into future
versions of this specification.
      </p>

      <section class="normative">
        <h3>Verification</h3>

        <p>
This section contains an algorithm that <a>conforming verifier
implementations</a> MUST run when verifying a [=verifiable credential=] or a
[=verifiable presentation=]. This algorithm takes a sequence of bytes
([=byte sequence=] |inputBytes|) or a document
([=map=] |inputDocument|) and a media type
([=string=] |inputMediaType|) as inputs, and returns a [=map=]
that contains the following:
        </p>

        <ul>
          <li>
a status ([=boolean=] |status|)
          </li>
          <li>
a [=conforming document=] ([=map=] |document|)
          </li>
          <li>
a media type ([=string=] |mediaType|)
          </li>
          <li>
a controller of the verification method associated with the securing mechanism
([=string=] |controller|)
          </li>
          <li>
a controller document that is associated with the verification method used
to verify the securing mechanism ([=map=] |controllerDocument|)
          </li>
          <li>
zero or more warnings ([=list=] of [=ProblemDetails=] |warnings|)
          </li>
          <li>
zero or more errors ([=list=] of [=ProblemDetails=] |errors|)
          </li>
        </ul>

        <p>
The verification algorithm is as follows:
        </p>

        <ol class="algorithm">
          <li>
Ensure that the securing mechanism has properly protected the
[=conforming document=] by performing the following steps:
            <ol class="algorithm">
             <li>
Set the |verifyProof| function by using the |inputMediaType| and the
<a data-cite="?VC-SPECS#securing-mechanisms">Securing Mechanisms</a> section of
the [[[?VC-SPECS]]] [[?VC-SPECS]], or other mechanisms known to the
implementation, to determine the cryptographic suite to use when verifying
the securing mechanism. The |verifyProof| function MUST implement the interface
described in <a href="#securing-mechanisms"></a>.
                <div class="issue"
                     title="Mechanism for 'determining' is being detailed">
At present, the Working Group is concerned that the algorithm for "determining"
might need to be more formally defined. At present, no implementation has
had an issue determining the proper |verifyProof| algorithm to use, but the
Working Group is attempting to see if saying more here would be worthwhile.
Additional example language could be added that says that an implementation
might have an allow list of acceptable cryptosuites -- and these will be used as
inputs for finding matching proofs to be verified.
                </div>
              </li>
              <li>
Set |result| to the result of passing |inputBytes| and
|inputMediaType| to the |verifyProof| function. If the call was
successful, |result| will contain the |status|,
|document|, |mediaType|, |controller|,
|controllerDocument|, |warnings|, and |errors|
properties.
              </li>
              <li>
If |result|.|status| is set to `false`, add a
<a href="#CRYPTOGRAPHIC_SECURITY_ERROR">CRYPTOGRAPHIC_SECURITY_ERROR</a> to
|result|.|errors|.
              </li>
            </ol>
          </li>
          <li>
If |result|.|status| is set to `true`, ensure that
|result|.|document| is a [=conforming document=]. If it is
not, set |result|.|status| to `false`, remove the
|document| property from |result|, and add at least
one <a href="#MALFORMED_VALUE_ERROR">MALFORMED_VALUE_ERROR</a> to
|result|.|errors|. Other warnings and errors MAY be included
to aid any debugging process.
          </li>
          <li>
Return |result|.
          </li>
        </ol>

        <p>
The steps for verifying the state of the securing mechanism and verifying
that the input document is a [=conforming document=] MAY be performed in
a different order than that provided above as long as the
implementation returns errors for the same invalid inputs.
Implementations MAY produce different errors than described above.
        </p>

      </section>

      <section>
        <h3>Problem Details</h3>

        <p>
When an implementation detects an anomaly while processing a document, a
<dfn>ProblemDetails</dfn> object can be used to report the issue to other
software systems. The interface for these types of objects follows [[RFC9457]]
to encode the data. A [=ProblemDetails=] object consists of the following
properties:
        </p>

        <dl>
          <dt>type</dt>
          <dd>
The `type` [=property=] MUST be present and its value MUST be a [=URL=]
identifying the type of problem.
          </dd>
          <dt>code</dt>
          <dd>
The `code` [=property=] is OPTIONAL.
present, its value MUST be an integer that identifies the type of the problem.
Integer codes are useful in systems that only provide integer return values.
          </dd>
          <dt>title</dt>
          <dd>
The `title` [=property=] MUST be present and its value SHOULD provide a short
but specific human-readable string for the problem.
          </dd>
          <dt>detail</dt>
          <dd>
The `detail` [=property=] MUST be present and its value SHOULD provide a
longer human-readable string for the problem.
          </dd>
        </dl>

        <p>
The following problem description types and codes are defined by this
specification:
        </p>

        <dl>
          <dt id="PARSING_ERROR">
https://www.w3.org/TR/vc-data-model#PARSING_ERROR
(-64)
          </dt>
          <dd>
There was an error while parsing input.
          </dd>
          <dt id="CRYPTOGRAPHIC_SECURITY_ERROR">
https://www.w3.org/TR/vc-data-model#CRYPTOGRAPHIC_SECURITY_ERROR
(-65)
          </dt>
          <dd>
The securing mechanism for the document has detected a
modification in the contents of the document since it was created;
potential tampering detected. See Section
<a href="#verification"></a>.
          </dd>
          <dt id="MALFORMED_VALUE_ERROR">
https://www.w3.org/TR/vc-data-model#MALFORMED_VALUE_ERROR
(-66)
          </dt>
          <dd>
The value associated with a particular [=property=] is malformed. The
name of the [=property=] and the path to the property SHOULD be provided
in the [=ProblemDetails=] object. See Section
<a href="#verification"></a>.
          </dd>
        </dl>

        <p>
Implementations MAY extend the [=ProblemDetails=] object by specifying
additional types, codes, or properties. See the
<a data-cite="RFC9457#name-extension-members">Extension Member</a> section
in [[RFC9457]] for further guidance on using this mechanism.
        </p>

      </section>

    </section>

    <section class="informative">
      <h2>Privacy Considerations</h2>

      <p>
This section details the general privacy considerations and specific privacy
implications of deploying the Verifiable Credentials Data Model into production
environments.
      </p>

      <section class="informative">
        <h3>Spectrum of Privacy</h3>

        <p>
It is important to recognize there is a spectrum of privacy ranging from
pseudonymous to strongly identified. Depending on the use case, people have
different comfort levels about what information they are willing to provide
and what information can be derived from what is provided.
        </p>

        <figure>
          <img style="margin: auto; display: block; width: 80%;"
            src="diagrams/privacy-spectrum.svg" alt="Horizontal bar with
            red on the left, orange in the middle, and green on the
            right.  The red has the text 'Highly correlatable (global
            IDs), e.g., government ID, shipping address, credit card
            number'.  The orange has the text 'Correlatable via collusion
            (personally identifiable info), e.g., name, birthday, zip
            code'.  The green has the text 'Non-correlatable
            (pseudonyms), e.g., age over 21'.">
          <figcaption style="text-align: center;">
Privacy spectrum ranging from pseudonymous to fully identified.
          </figcaption>
        </figure>

        <p>
For example, most people probably want to remain anonymous when purchasing
alcohol because the regulatory check required is solely based on whether a
person is above a specific age. Alternatively, for medical prescriptions
written by a doctor for a patient, the pharmacy fulfilling the prescription is
required to more strongly identify the medical professional and the patient.
Therefore there is not one approach to privacy that works for all use cases.
Privacy solutions are use case specific.
        </p>

        <p class="note">
Even for those wanting to remain anonymous when purchasing alcohol, photo
identification might still be required to provide appropriate assurance to the
merchant. The merchant might not need to know your name or other details (other
than that you are over a specific age), but in many cases just proof of age
might still be insufficient to meet regulations.
        </p>

        <p>
The Verifiable Credentials Data Model strives to support the full privacy
spectrum and does not take philosophical positions on the correct level of
anonymity for any specific transaction. The following sections provide guidance
for implementers who want to avoid specific scenarios that are hostile to
privacy.
        </p>
      </section>

      <section class="informative">
        <h3>Software Trust Boundaries</h3>

        <p>
A variety of trust relationships exist in the
<a href="#ecosystem-overview">ecosystem described by this specification</a>. An
individual using a web browser trusts the web browser, also known as a <a
href="https://www.w3.org/TR/UAAG20/#def-user-agent">user agent</a>, to preserve
that trust by not uploading their personal information to a data broker;
similarly, entities filling the roles in the ecosystem described by this
specification trust the software that operates on behalf of each of those roles.
Examples include the following:
        </p>

        <ul>
          <li>
An [=issuer's=]
<a href="https://www.w3.org/TR/UAAG20/#def-user-agent">user agent</a>
(issuer software), such as an online education platform, is expected to only
issue [=verifiable credentials=] to individuals that the issuer asserts
have completed their educational program.
          </li>
          <li>
A [=verifier's=]
<a href="https://www.w3.org/TR/UAAG20/#def-user-agent">user agent</a>
(verification software), such as a hiring website, is expected to only allow
access to individuals with a valid verification status for
[=verifiable credentials=] and [=verifiable presentations=] provided to
the platform by such individuals.
          </li>
          <li>
A [=holder's=]
<a href="https://www.w3.org/TR/UAAG20/#def-user-agent">user agent</a>
(holder software), such as a digital wallet, is expected to only divulge
information to a [=verifier=] when the [=holder=] has consented to
the release of that information.
          </li>
        </ul>

        <p>
The examples above are not exhaustive, and the users in these roles can also
expect a variety of other things from the software they use to achieve their
goals. In short, the software is expected to operate in the best interests
of the user, and a violation of that expectation is a violation of trust
that will result in the software being replaced by something that does not
violate that trust. Implementers are strongly advised to write software that
does not violate the trust of the users it will serve. Implementers are
also advised to provide auditing features in the software that they create
such that the users, or trusted third parties, can check whether the software
is indeed behaving in their best interests.
        </p>

        <p>
Readers are advised that some software, such as a website that provides services
to a single [=verifier=] and multiple [=holders=], might operate as a
<a href="https://www.w3.org/TR/UAAG20/#def-user-agent">user agent</a> to both
roles, but might not always be able to simultaneously operate in the best
interests of all parties. For example, if that website detects an attempt at
fraudulent [=verifiable credential=] use among multiple [=holders=], it
might report such an anomaly to the [=verifier=], which might be considered
to not be in the best interest of the [=holder=] committing the violation,
but would be in the best interest of the [=verifier=] as well as any
[=holders=] <em>not</em> committing such a violation. It is strongly advised
that when software operates in this manner, that it is made clear in whose best
interest the software is operating through mechanisms such as a website usage
policy.
        </p>
      </section>

      <section class="informative">
        <h3>Personally Identifiable Information</h3>

        <p>
Data associated with [=verifiable credentials=] stored in the
`credential.credentialSubject` field is susceptible to privacy
violations when shared with [=verifiers=]. Personally identifying data, such
as a government-issued identifier, shipping address, and full name, can be
easily used to determine, track, and correlate an [=entity=]. Even
information that does not seem personally identifiable, such as the
combination of a birthdate and a postal code, has very powerful correlation
and de-anonymizing capabilities.
        </p>

        <p>
Implementers are strongly advised to warn [=holders=] when they share data
with these kinds of characteristics. [=Issuers=] are strongly advised to
provide privacy-protecting [=verifiable credentials=] when possible. For
example, issuing `ageOver` [=verifiable credentials=] instead of
date of birth [=verifiable credentials=] when a [=verifier=] wants to
determine whether an [=entity=] is over the age of 18.
        </p>

        <p>
Because a [=verifiable credential=] often contains personally identifiable
information (PII), implementers are strongly advised to use mechanisms while
storing and transporting [=verifiable credentials=] that protect the data
from those who should not access it. Mechanisms that could be considered include
Transport Layer Security (TLS) or other means of encrypting the data while in
transit, as well as encryption or data access control mechanisms to protect
the data in a [=verifiable credential=] while at rest.
        </p>
      </section>

      <section class="informative">
        <h3>Identifier-Based Correlation</h3>

        <p>
[=Subjects=] of [=verifiable credentials=] are identified using the
`credential.credentialSubject.id` field. The identifiers used to
identify a [=subject=] create a greater risk of correlation when the
identifiers are long-lived or used across more than one web domain.
        </p>

        <p>
Similarly, disclosing the [=credential=] identifier
(`credential.id`) leads to situations where multiple
[=verifiers=], or an [=issuer=] and a [=verifier=], can collude to
correlate the [=holder=]. If [=holders=] want to reduce correlation, they
should use [=verifiable credential=] schemes that allow hiding the
identifier during [=verifiable presentation=]. Such schemes expect the
[=holder=] to generate the identifier and might even allow hiding the
identifier from the [=issuer=], while still keeping the identifier embedded
and signed in the [=verifiable credential=].
        </p>

        <p>
If strong anti-correlation properties are a requirement in a
[=verifiable credentials=] system, it is strongly advised that identifiers
are either:
        </p>

        <ul>
          <li>
Bound to a single origin
          </li>
          <li>
Single-use
          </li>
          <li>
Not used at all, but instead replaced by short-lived, single-use bearer tokens.
          </li>
        </ul>
      </section>

      <section class="informative">
        <h3>Signature-Based Correlation</h3>

        <p>
The contents of [=verifiable credentials=] are secured using the
`credential.proof` field. The [=properties=] in this field
create a greater risk of correlation when the same values are used across more
than one session or domain and the value does not change. Examples include the
`verificationMethod`, `created`,
`proofPurpose`, and `jws` fields.
        </p>

        <p>
If strong anti-correlation properties are required, it is advised that
signature values and metadata are regenerated each time using technologies like
third-party pairwise signatures, zero-knowledge proofs, or group signatures.
        </p>

        <p class="note">
Even when using anti-correlation signatures, information might still be
contained in a [=verifiable credential=] that defeats the anti-correlation
properties of the cryptography used.
        </p>
      </section>

      <section class="informative">
        <h3>Long-Lived Identifier-Based Correlation</h3>

        <p>
[=Verifiable credentials=] might contain long-lived identifiers that could
be used to correlate individuals. These types of identifiers include
[=subject=] identifiers, email addresses, government-issued identifiers,
organization-issued identifiers, addresses, healthcare vitals,
[=verifiable credential=]-specific JSON-LD contexts, and many other sorts of
long-lived identifiers.
        </p>

        <p>
Organizations providing software to [=holders=] should strive to identify
fields in [=verifiable credentials=] containing information that could be
used to correlate individuals and warn [=holders=] when this information is
shared.
        </p>
      </section>

      <section class="informative">
        <h3>Metadata-based Correlation</h3>

        <p>
The use of different extension points described in Section
<a href="#basic-concepts"></a> and Section <a href="#advanced-concepts"></a>
can serve as an unintentional or unwanted correlation mechanism if the number
of [=issuers=] using a specific extension type or combination of types
is relatively small.
For example, the use of certain types of cryptography that are only used by
particular nation states, or revocation formats used by specific jurisdictions,
or credential types used by specific localities, can be used as a mechanism
to reduce the pseudonymity that a [=holder=] might expect to have when
performing a selective disclosure of information to a [=verifier=].
        </p>

        <p>
[=Issuers=] are urged to reduce metadata-based correlation possibilities when
issuing [=verifiable credentials=] that are expected to be used in a
pseudonymous fashion by reducing the types of extensions that can be used to
narrow the pseudonymity of the [=holder=]. Using credential types,
extensions, and technology profiles that have global use is preferred over ones
that have national use, which are preferred over ones that only have local use.
        </p>
      </section>

      <section class="informative">
        <h3>Device Tracking and Fingerprinting</h3>

        <p>
There are mechanisms external to [=verifiable credentials=] that are used to
track and correlate individuals on the Internet and the Web. Some of these
mechanisms include Internet protocol (IP) address tracking, web browser
fingerprinting, evercookies, advertising network trackers, mobile network
position information, and in-application Global Positioning System (GPS) APIs.
Using [=verifiable credentials=] cannot prevent the use of these other
tracking technologies. Also, when these technologies are used in conjunction
with [=verifiable credentials=], new correlatable information could be
discovered. For example, a birthday coupled with a GPS position can be used to
strongly correlate an individual across multiple websites.
        </p>

        <p>
It is recommended that privacy-respecting systems prevent the use of these
other tracking technologies when [=verifiable credentials=] are being used.
In some cases, tracking technologies might need to be disabled on devices that
transmit [=verifiable credentials=] on behalf of a [=holder=].
        </p>

        <p>
The Oblivious HTTP protocol [[?OHTTP]] is one mechanism that implementers might
consider using when fetching external resources that are associated with a
[=verifiable credential=] or a [=verifiable presentation=].
Oblivious HTTP allows a client to make multiple requests to an origin server
without that server being able to link those requests to that client or even to
identify those requests as having come from a single client, while placing only
limited trust in the nodes used to forward the messages. Hence, Oblivious HTTP
is one privacy-preserving mechanism that can be used to reduce the possibility
of device tracking and fingerprinting. Concrete examples for how Oblivious HTTP
can benefit ecosystem participants are included below.
        </p>

        <ul>
          <li>
A [=holder=] using a digital wallet can reduce the chances that they
will be tracked by a 3rd party when accessing external links within a
[=verifiable credential=] stored in their digital wallet.
For example, a digital wallet might fetch and render linked images, or
check the validity of a [=verifiable credential=] by fetching an
externally linked revocation list.
          </li>
          <li>
A [=verifier=] can reduce signalling to an [=issuer=] that the
[=verifier=] has received a specific [=verifiable credential=].
For example, a [=verifier=] might fetch an externally linked revocation
list while performing status checks on a [=verifiable credential=].
          </li>
        </ul>
      </section>

      <section class="informative">
        <h3>Favor Abstract Claims</h3>

        <p>
To enable recipients of [=verifiable credentials=] to use them in a variety
of circumstances without revealing more PII than necessary for transactions,
[=issuers=] should consider limiting the information published in a
[=credential=] to a minimal set needed for the expected purposes. One way to
avoid placing PII in a [=credential=] is to use an abstract [=property=]
that meets the needs of [=verifiers=] without providing specific information
about a [=subject=].
        </p>
        <p>
For example, this document uses the `ageOver` [=property=]
instead of a specific birthdate, which constitutes much stronger PII. If
retailers in a specific market commonly require purchasers to be older than a
certain age, an [=issuer=] trusted in that market might choose to offer a
[=verifiable credential=] claiming that [=subjects=] have met that
requirement instead of offering [=verifiable credentials=] containing
[=claims=] about specific birthdates. This enables individual customers to
make purchases without revealing specific PII.
        </p>
      </section>

      <section class="informative">
        <h3>The Principle of Data Minimization</h3>

        <p>
Privacy violations occur when information divulged in one context leaks into
another. Accepted best practice for preventing such violations is to limit the
information requested, and received, to the absolute minimum necessary. This
data minimization approach is required by regulation in multiple jurisdictions,
including the Health Insurance Portability and Accountability Act (HIPAA) in the
United States and the General Data Protection Regulation (GDPR) in the European
Union.
        </p>
        <p>
With [=verifiable credentials=], data minimization for [=issuers=] means
limiting the content of a [=verifiable credential=] to the minimum required
by potential [=verifiers=] for expected use. For [=verifiers=], data
minimization means limiting the scope of the information requested or
required for accessing services.
        </p>
        <p>
For example, a driver's license containing a driver's ID number, height, weight,
birthday, and home address is a [=credential=] containing more information
than is necessary to establish that the person is above a certain age.
        </p>

        <p>
It is considered best practice for [=issuers=] to atomize information or use
a signature scheme that allows for [=selective disclosure=]. For example, an
[=issuer=] of driver's licenses could issue a [=verifiable credential=]
containing every attribute that appears on a driver's license, as well as a set
of [=verifiable credentials=] where every [=verifiable credential=]
contains only a single attribute, such as a person's birthday. It could also
issue more abstract [=verifiable credentials=] (for example, a
[=verifiable credential=] containing only an `ageOver` attribute).
One possible adaptation would be for [=issuers=] to provide secure HTTP
endpoints for retrieving single-use [=bearer credentials=] that promote the
pseudonymous usage of [=verifiable credentials=]. Implementers that find this
impractical or unsafe, should consider using [=selective disclosure=] schemes
that eliminate dependence on [=issuers=] at proving time and reduce temporal
correlation risk from [=issuers=].
        </p>

        <p>
[=Verifiers=] are urged to only request information that is absolutely
necessary for a specific transaction to occur. This is important for at least
two reasons. It:
        </p>

        <ul>
          <li>
Reduces the liability on the [=verifier=] for handling highly sensitive
information that it does not need to.
          </li>
          <li>
Enhances the privacy of the individual by only asking for information required
for a specific transaction.
          </li>
        </ul>

        <p class="note">
While it is possible to practice the principle of minimum disclosure, it might
be impossible to avoid the strong identification of an individual for
specific use cases during a single session or over multiple sessions. The
authors of this document cannot stress how difficult it is to meet this
principle in real-world scenarios.
        </p>
      </section>

      <section class="informative">
        <h3>Bearer Credentials</h3>

        <p>
A <dfn data-lt="bearer credentials">bearer credential</dfn> is a
privacy-enhancing piece of information, such as a concert ticket, which entitles
the [=holder=] of the bearer credential to a specific resource without
divulging sensitive information about the [=holder=]. Bearer credentials are
often used in low-risk use cases where the sharing of the bearer credential is
not a concern or would not result in large economic or reputational losses.
        </p>

        <p>
[=Verifiable credentials=] that are [=bearer credentials=] are made
possible by not specifying the [=subject=] identifier, expressed using the
`id` [=property=], which is nested in the
`credentialSubject` [=property=]. For example, the following
[=verifiable credential=] is a [=bearer credential=]:
        </p>

        <pre class="example nohighlight vc"
          title="Usage of issuer properties"
          data-vc-vm="https://university.example/issuers/14#keys-1">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2",
    "https://www.w3.org/ns/credentials/examples/v2"
  ],
  "id": "http://university.example/credentials/temporary/28934792387492384",
  "type": ["VerifiableCredential", "ExampleDegreeCredential"],
  "issuer": "https://university.example/issuers/14",
  "validFrom": "2017-10-22T12:23:48Z",
  "credentialSubject": {
    <span class="comment">// note that the 'id' property is not specified for bearer credentials</span>
    "degree": {
      "type": "ExampleBachelorDegree",
      "name": "Bachelor of Science and Arts"
    }
  }
}
        </pre>

        <p>
While [=bearer credentials=] can be privacy-enhancing, they must be carefully
crafted so as not accidentally divulge more information than the [=holder=]
of the [=bearer credential=] expects. For example, repeated use of the same
[=bearer credential=] across multiple sites enables these sites to
potentially collude to unduly track or correlate the [=holder=]. Likewise,
information that might seem non-identifying, such as a birthdate and postal
code, can be used to statistically identify an individual when used together in
the same [=bearer credential=] or session.
        </p>

        <p>
[=Issuers=] of [=bearer credentials=] should ensure that the
[=bearer credentials=] provide privacy-enhancing benefits that:
        </p>

        <ul>
          <li>
Are single-use, where possible.
          </li>
          <li>
Do not contain personally identifying information.
          </li>
          <li>
Are not unduly correlatable.
          </li>
        </ul>

        <p>
[=Holders=] should be warned by their software if [=bearer credentials=]
containing sensitive information are issued or requested, or if there is a
correlation risk when combining two or more [=bearer credentials=] across one
or more sessions. While it might be impossible to detect all correlation risks,
some might certainly be detectable.
        </p>

        <p>
[=Verifiers=] should not request [=bearer credentials=] that can be used
to unduly correlate the [=holder=].
        </p>
      </section>

      <section class="informative">
        <h3>Validation</h3>

        <p>
When processing [=verifiable credentials=], [=verifiers=]
evaluate any relevant [=claims=] before relying upon them. This
evaluation might be done in any manner desired, as long as it satisfies
the requirements of the [=verifier=] doing the validation.
Many verifiers will perform the checks listed in Appendix <a
href="#validation-0"></a> as well as a variety of specific business process
checks such as:
        </p>

        <ul>
          <li>
The professional licensure status of the [=holder=].
          </li>
          <li>
A date of license renewal or revocation.
          </li>
          <li>
The sub-qualifications of an individual.
          </li>
          <li>
If a relationship exists between the [=holder=] and the [=entity=]
with whom the [=holder=] is attempting to interact.
          </li>
          <li>
The geolocation information associated with the [=holder=].
          </li>
        </ul>

        <p>
The process of performing these checks might result in information leakage that
leads to a privacy violation of the [=holder=]. For example, a simple
operation, such as checking an improperly configured revocation list, can
notify the [=issuer=] that a specific business is likely interacting
with the [=holder=]. This could
enable [=issuers=] to collude to correlate individuals without their
knowledge.
        </p>

        <p>
[=Issuers=] are urged to not use mechanisms, such as [=credential=]
revocation lists that are unique per [=credential=], during the
[=verification=] process that could lead to privacy violations. Organizations
providing software to [=holders=] should warn when [=credentials=] include
information that could lead to privacy violations during the verification
process. [=Verifiers=] should consider rejecting [=credentials=] that
produce privacy violations or that enable bad privacy practices.
        </p>
      </section>

      <section class="informative">
        <h3>Storage Providers and Data Mining</h3>

        <p>
When a [=holder=] receives a [=verifiable credential=] from an
[=issuer=], the [=verifiable credential=] needs to be stored somewhere
(for example, in a [=credential=] repository). [=Holders=] are warned that
the information in a [=verifiable credential=] is sensitive in nature and
highly individualized, making it a high value target for data mining. Services
that advertise free storage of [=verifiable credentials=] might in fact be
mining personal data and selling it to organizations wanting to build
individualized profiles on people and organizations.
        </p>
        <p>
[=Holders=] need to be aware of the terms of service for their
[=credential=] repository, specifically the correlation and data mining
protections in place for those who store their [=verifiable credentials=]
with the service provider.
        </p>
        <p>
Some effective mitigations for data mining and profiling include using:
        </p>

        <ul>
          <li>
Service providers that do not sell your information to third parties.
          </li>
          <li>
Software that encrypts [=verifiable credentials=] such that a service
provider cannot view the contents of the [=credential=].
          </li>
          <li>
Software that stores [=verifiable credentials=] locally on a device that you
control and that does not upload or analyze your information beyond your
expectations.
          </li>
        </ul>
      </section>

      <section class="informative">
        <h3>Aggregation of Credentials</h3>

        <p>
Holding two pieces of information about the same [=subject=] almost always
reveals more about the [=subject=] than just the sum of the two pieces, even
when the information is delivered through different channels. The aggregation of
[=verifiable credentials=] is a privacy risk and all participants in
the ecosystem need to be aware of the risks of data aggregation.
        </p>

        <p>
For example, if two [=bearer credentials=], one for an email address and then
one stating the [=holder=] is over the age of 21, are provided across
multiple sessions, the [=verifier=] of the information now has a unique
identifier as well as age-related information for that individual. It is now
easy to create and build a profile for the [=holder=] such that more and more
information is leaked over time. Aggregation of [=credentials=] can also be
performed across multiple sites in collusion with each other, leading to privacy
violations.
        </p>

        <p>
From a technological perspective, preventing aggregation of information is a
very difficult privacy problem to address. While new cryptographic techniques,
such as zero-knowledge proofs, are being proposed as solutions to the problem
of aggregation and correlation, the existence of long-lived identifiers and
browser tracking techniques defeats even the most modern cryptographic
techniques.
        </p>

        <p>
The solution to the privacy implications of correlation or aggregation tends not
to be technological in nature, but policy driven instead. Therefore, if a
[=holder=] does not want information about them to be aggregated, they must
express this in the [=verifiable presentations=] they transmit.
        </p>
      </section>

      <section class="informative">
        <h3>Usage Patterns</h3>

        <p>
Despite the best efforts to assure privacy, actually using
[=verifiable credentials=] can potentially lead to de-anonymization and a
loss of privacy. This correlation can occur when:
        </p>

        <ul>
          <li>
The same [=verifiable credential=] is presented to the same [=verifier=]
more than once. The [=verifier=] could infer that the [=holder=] is the
same individual.
          </li>
          <li>
The same [=verifiable credential=] is presented to different
[=verifiers=], and either those [=verifiers=] collude or a third party
has access to transaction records from both [=verifiers=]. An observant
party could infer that the individual presenting the
[=verifiable credential=] is the same person at both services. That is, the
accounts are controlled by the same person.
          </li>
          <li>
A [=subject=] identifier of a [=credential=] refers to the same
[=subject=] across multiple [=presentations=] or [=verifiers=]. Even
when different [=credentials=] are presented, if the [=subject=]
identifier is the same, [=verifiers=] (and those with access to
[=verifier=] logs) could infer that the [=holder=] of the
[=credential=] is the same person.
          </li>
          <li>
The underlying information in a [=credential=] can be used to identify an
individual across services. In this case, using information from other sources
(including information provided directly by the [=holder=]), [=verifiers=]
can use information inside the [=credential=] to correlate the individual
with an existing profile. For example, if a [=holder=] presents
[=credentials=] that include postal code, age, and gender, a [=verifier=]
can potentially correlate the [=subject=] of that [=credential=] with an
established profile. For more information, see [[DEMOGRAPHICS]].
          </li>
          <li>
Passing the identifier of a [=credential=] to a centralized revocation
server. The centralized server can correlate the [=credential=] usage across
interactions. For example, if a [=credential=] is used for proof of age in
this manner, the centralized service could know everywhere that
[=credential=] was presented (all liquor stores, bars, adult stores, lottery
purchases, and so on).
          </li>
        </ul>

        <p>
In part, it is possible to mitigate this de-anonymization and loss of privacy
by:
        </p>

        <ul>
          <li>
Using a globally-unique identifier as the [=subject=] for any given
[=credential=] and never re-use that [=credential=].
          </li>
          <li>
If the [=credential=] supports revocation, using a globally-distributed
service for revocation.
          </li>
          <li>
Designing revocation APIs that do not depend on submitting the ID of the
[=credential=]. For example, use a revocation list instead of a query.
          </li>
          <li>
Avoiding the association of personally identifiable information with any
specific long-lived [=subject=] identifier.
          </li>
        </ul>

        <p>
It is understood that these mitigation techniques are not always practical
or even compatible with necessary usage. Sometimes correlation is a
requirement.
        </p>
        <p>
For example, in some prescription drug monitoring programs, usage monitoring is
a requirement. Enforcement entities need to be able to confirm that individuals
are not cheating the system to get multiple prescriptions for controlled
substances. This statutory or regulatory need to correlate usage overrides
individual privacy concerns.
        </p>

        <p>
[=Verifiable credentials=] will also be used to intentionally correlate
individuals across services, for example, when using a common persona to log in
to multiple services, so all activity on each of those services is
intentionally linked to the same individual. This is not a privacy issue as
long as each of those services uses the correlation in the expected manner.
        </p>

        <p>
Privacy risks of [=credential=] usage occur when unintended or unexpected
correlation arises from the presentation of [=credentials=].
        </p>
      </section>

      <section class="informative">
        <h3>Sharing Information with the Wrong Party</h3>

        <p>
When a [=holder=] chooses to share information with a [=verifier=], it
might be the case that the [=verifier=] is acting in bad faith and requests
information that could be used to harm the [=holder=]. For example, a
[=verifier=] might ask for a bank account number, which could then be used
with other information to defraud the [=holder=] or the bank.
        </p>

        <p>
[=Issuers=] should strive to tokenize as much information as possible such
that if a [=holder=] accidentally transmits [=credentials=] to the wrong
[=verifier=], the situation is not catastrophic.
        </p>

        <p>
For example, instead of including a bank account number for the purpose of
checking an individual's bank balance, provide a token that enables the
[=verifier=] to check if the balance is above a certain amount. In this
case, the bank could issue a [=verifiable credential=] containing a balance
checking token to a [=holder=]. The [=holder=] would then include the
[=verifiable credential=] in a [=verifiable presentation=] and bind the
token to a credit checking agency using a digital signature. The
[=verifier=] could then wrap the [=verifiable presentation=] in their
digital signature, and hand it back to the issuer to dynamically check the
account balance.
        </p>

        <p>
Using this approach, even if a [=holder=] shares the account balance token
with the wrong party, an attacker cannot discover the bank account number, nor
the exact value in the account. And given the validity period for the
counter-signature, does not gain access to the token for more than a few
minutes.
        </p>
      </section>

      <section class="informative">
        <h3>Data Theft</h3>

        <p>
The data expressed in [=verifiable credentials=] and
[=verifiable presentations=] are valuable since they contain authentic
statements made by trusted third parties, such as [=issuers=], or
individuals, such as [=holders=] and [=subjects=]. Storing this data
can create honeypots of sensitive data that attackers are motivated to
break into in order to acquire and exchange that data for financial gain.
        </p>
        <p>
[=Issuers=] are advised to retain the minimum amount of data
necessary to issue [=verifiable credentials=] to [=holders=] and
manage the status and revocation of those credentials.
        </p>
        <p>
[=Holders=] are advised to use implementations that appropriately
encrypt their data both in transit and at rest, and protect sensitive
material (such as cryptographic secrets) in ways that cannot be easily
extracted from hardware devices. Furthermore, it is suggested that
[=holders=] store and manipulate their data only on devices that they
control, away from centralized systems, to reduce the likelihood of
attack on their data, or large-scale theft if an attack is successful.
        </p>
        <p>
[=Verifiers=] are advised to only ask for data necessary for a particular
transaction and to not retain any data beyond the needs of any particular
transaction.
        </p>
        <p>
Regulators are advised to rethink audit requirements such that more
privacy-preserving mechanisms can be used to achieve similar levels of
enforcement and audit capabilities. For example, audit-focused regulations
that insist on collection and long-term retention of personally identifiable
information can cause harm to individuals and organizations if that same
information is compromised and accessed by an attacker. The technologies
described by this specification enable [=holders=] to more-readily prove
attributes about themselves and others, reducing the need for long-term data
retention by [=verifiers=]. Alternatives include keeping logs that the
information was collected and checked, as well as random tests to ensure
that compliance regimes are operating as expected.
        </p>
      </section>

      <section class="informative">
        <h3>Frequency of Claim Issuance</h3>

        <p>
As detailed in Section <a href="#usage-patterns"></a>, usage patterns can be
correlated into certain types of behavior. Part of this correlation is
mitigated when a [=holder=] uses a [=verifiable credential=] without the
knowledge of the [=issuer=]. [=Issuers=] can defeat this protection
however, by making their [=verifiable credentials=] short lived and renewal
automatic.
        </p>

        <p>
For example, an `ageOver` [=verifiable credential=] is useful for
gaining access to a bar. If an [=issuer=] issues such a
[=verifiable credential=] with a very short validity period and an automatic
renewal mechanism, then the [=issuer=] could possibly correlate the behavior
of the [=holder=] in a way that negatively impacts the [=holder=].
        </p>

        <p>
Organizations providing software to [=holders=] should warn them if they
repeatedly use [=credentials=] with short lifespans, which could result in
behavior correlation. [=Issuers=] should avoid issuing [=credentials=] in
a way that enables them to correlate usage patterns.
        </p>
      </section>

      <section class="informative">
        <h3>Prefer Single-Use Credentials</h3>

        <p>
An ideal privacy-respecting system would require only the information necessary
for interaction with the [=verifier=] to be disclosed by the [=holder=].
The [=verifier=] would then record that the disclosure requirement was met
and forget any sensitive information that was disclosed. In many cases,
competing priorities, such as regulatory burden, prevent this ideal system from
being employed. In other cases, long-lived identifiers prevent single use. The
design of any [=verifiable credentials=] ecosystem, however, should strive
to be as privacy-respecting as possible by preferring single-use
[=verifiable credentials=] whenever possible.
        </p>

        <p>
Using single-use [=verifiable credentials=] provides several benefits. The
first benefit is to [=verifiers=] who can be sure that the data in a
[=verifiable credential=] is fresh. The second benefit is to [=holders=],
who know that if there are no long-lived identifiers in the
[=verifiable credential=], the [=verifiable credential=] itself cannot be
used to track or correlate them online. Finally, there is nothing for attackers
to steal, making the entire ecosystem safer to operate within.
        </p>
      </section>

      <section class="informative">
        <h3>Private Browsing</h3>

        <p>
In an ideal private browsing scenario, no PII will be revealed. Because many
[=credentials=] include PII, organizations providing software to
[=holders=] should warn them about the possibility of revealing this
information if they wish to use [=credentials=] and [=presentations=]
while in private browsing mode. As each browser vendor handles private browsing
differently, and some browsers might not have this feature at all, it is
important for implementers to be aware of these differences and implement
solutions accordingly.
        </p>
      </section>

      <section class="informative">
        <h3>Issuer Cooperation Impacts on Privacy</h3>

        <p>
It cannot be overstated that [=verifiable credentials=] rely on a high degree
of trust in [=issuers=]. The degree to which a [=holder=] might take
advantage of possible privacy protections often depends strongly on the support
an [=issuer=] provides for such features. In many cases, privacy protections
which make use of zero-knowledge proofs, data minimization techniques, bearer
credentials, abstract claims, and protections against signature-based
correlation, require the [=issuer=] to actively support such capabilities and
incorporate them into the [=verifiable credentials=] they issue.
        </p>
        <p>
It should also be noted that, in addition to a reliance on [=issuer=]
participation to provide [=verifiable credential=] capabilities that help
preserve [=holder=] and [=subject=] privacy, [=holders=] rely on
[=issuers=] to not deliberately subvert privacy protections. For example, an
[=issuer=] might sign [=verifiable credentials=] using a signature scheme
that protects against signature-based correlation. This would protect the
[=holder=] from being correlated by the signature value as it is shared among
[=verifiers=]. However, if the [=issuer=] creates a unique key for each
issued [=credential=], it might be possible for the [=issuer=] to track
[=presentations=] of the [=credential=], regardless of a [=verifier=]'s
inability to do so.
        </p>
        <p>
In addition to previously described privacy protections an [=issuer=] might
use, [=issuers=] need to also be aware of data they leak associated with
identifiers and claim types they use when issuing [=credentials=]. One
example of this would be an [=issuer=] issuing drivers licenses which reveal
both the location(s) in which they have jurisdiction and the location of the
[=subject's=] residence. [=Verifiers=] might take advantage of this by
requesting a [=credential=] to check that the [=subject=] is licensed to
drive, when in fact they are interested in metadata <em>about</em> the
credential, such as which [=issuer=] issued the credential, and tangential
information that might have been leaked by the [=issuer=], such as the
subject's home address. To mitigate such leakage, [=issuers=] might choose to
use common identifiers to mask specific location information or other sensitive
metadata; for example, a shared issuer identifier at a state or nation level,
instead of at the level of a county, city, town, or other smaller municipality.
Further, [=holder=] attestation mechanisms can be used by [=verifiers=] to
preserve privacy, by providing proofs that an [=issuer=] exists in a set of
trusted entities, without needing to disclose the exact [=issuer=].
        </p>
      </section>
    </section>

    <section class="informative">
      <h2>Security Considerations</h2>

      <p>
There are a number of security considerations that [=issuers=],
[=holders=], and [=verifiers=] should be aware of when processing data
described by this specification. Ignoring or not understanding the implications
of this section can result in security vulnerabilities.
      </p>

      <p>
While this section attempts to highlight a broad set of security considerations,
it is not a complete list. Implementers are urged to seek the advice of security
and cryptography professionals when implementing mission critical systems using
the technology outlined in this specification.
      </p>

      <section class="informative">
        <h3>Cryptography Suites and Libraries</h3>

        <p>
Some aspects of the data model described in this specification can be
protected through the use of cryptography. It is important for implementers to
understand the cryptography suites and libraries used to create and process
[=credentials=] and [=presentations=]. Implementing and auditing
cryptography systems generally requires substantial experience. Effective
<a href="https://en.wikipedia.org/wiki/Red_team">red teaming</a> can also
help remove bias from security reviews.
        </p>

        <p>
Cryptography suites and libraries have a shelf life and eventually fall to
new attacks and technology advances. Production quality systems need to take
this into account and ensure mechanisms exist to easily and proactively upgrade
expired or broken cryptography suites and libraries, and to invalidate
and replace existing [=credentials=]. Regular monitoring is important to
ensure the long term viability of systems processing [=credentials=].
        </p>
      </section>

      <section class="informative">
        <h3>Key Management</h3>
        <p>
The security of most digital signature algorithms, which are used to secure
[=verifiable credentials=] and [=verifiable presentations=], is dependent
on the quality and protection of their <em>private signing keys</em>. Guidance
in the management of cryptographic keys is a large subject and the reader is
referred to [[NIST-SP-800-57-Part-1]] for more extensive recommendations and
discussion. As strongly recommended in both [[FIPS-186-5]] and
[[NIST-SP-800-57-Part-1]], a private signing key is not to be used for multiple
purposes, e.g., a private signing key is not to be used for encryption as well
as signing.
        </p>
        <p>
[[NIST-SP-800-57-Part-1]] strongly advises that private signing keys and
<em>public verification keys</em> have limited <em>cryptoperiods</em>, where
a <em>cryptoperiod</em> is &quot;the time span during which a specific key is
authorized for use by legitimate entities or the keys for a given system will
remain in effect.&quot; [[NIST-SP-800-57-Part-1]] gives extensive
guidance on cryptoperiods for different key types under different situations,
and generally recommends a 1-3 year cryptoperiod for a private signing key.
        </p>
        <p>
To deal with potential private key compromises, [[NIST-SP-800-57-Part-1]]
provides recommendations for protective measures, harm reduction, and
revocation. Although this section focuses primarily on the security of the
private signing key, [[NIST-SP-800-57-Part-1]] also highly recommends
confirmation of the validity of all public keys before using them.
        </p>
      </section>

      <section class="informative">
        <h3>Content Integrity Protection</h3>

        <p>
[=Verifiable credentials=] often contain URLs to data that resides outside of
the [=verifiable credential=] itself. Linked content that exists outside a
[=verifiable credential=], such as images, JSON-LD Contexts, JSON Schemas,
and other machine-readable data, are often not protected against tampering
because the data resides outside of the protection of the
<a href="#securing-mechanisms">securing mechanism</a> on the
[=verifiable credential=]. For example, the content retrievable by
dereferencing the following highlighted links is not integrity protected, but
probably ought to be:
        </p>

        <pre class="example nohighlight"
          title="Non-content-integrity protected links">
{
  "@context": [
    <span class="highlight">"https://www.w3.org/ns/credentials/v2"</span>,
    <span class="highlight">"https://www.w3.org/ns/credentials/examples/v2"</span>
  ],
  "id": "http://university.example/credentials/58473",
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "image": <span class="highlight">"https://university.example/images/58473"</span>,
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": "Example University"
    }
  }
}
        </pre>

        <p>
While this specification does not recommend any specific content integrity
protection, document authors who want to ensure links to content are integrity
protected are advised to use URL schemes that enforce content integrity.
        </p>

        <pre class="example nohighlight" title="Content-integrity protection for links to external data">
{
  "@context": [
    "https://www.w3.org/ns/credentials/v2<span class="highlight">?hl=z3aq31uzgnZBuWNzUB</span>",
    "https://www.w3.org/ns/credentials/examples/v2<span class="highlight">?hl=z8guWNzUBnZBu3aq31</span>"
  ],
  "id": "http://university.example/credentials/58473",
  "type": ["VerifiableCredential", "ExampleAlumniCredential"],
  "credentialSubject": {
    "id": "did:example:ebfeb1f712ebc6f1c276e12ec21",
    "image": <span class="highlight">"https://example.com/image"</span>,
    "alumniOf": {
      "id": "did:example:c276e12ec21ebfeb1f712ebc6f1",
      "name": "Example University"
    }
  }
}
        </pre>

        <p class="note">
It is debatable whether the JSON-LD Contexts above need protection because
production implementations are expected to ship with static copies of important
JSON-LD Contexts.
        </p>

        <p>
While the example above is one way to achieve content integrity protection,
there are other solutions that might be better suited for certain applications.
Implementers are urged to understand how links to external machine-readable
content that are not content-integrity protected could result in successful
attacks against their applications.
        </p>

      </section>

      <section class="informative">
        <h3>Unsigned Claims</h3>

        <p>
This specification allows [=credentials=] to be produced that do not contain
signatures or proofs of any kind. These types of [=credentials=] are often
useful for intermediate storage, or self-asserted information, which is
analogous to filling out a form on a web page. Implementers should be aware that
these types of [=credentials=] are not [=verifiable=] because the
authorship either is not known or cannot be trusted.
        </p>
      </section>

      <section class="informative">
        <h3>Man-in-the-Middle (MITM), Replay, and Cloning Attacks</h3>

        <p>
The data model does not inherently prevent
<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">Man-in-the-Middle (MITM)</a>,
<a href="https://en.wikipedia.org/wiki/Replay_attack">replay</a>, and
<a href="https://en.wikipedia.org/wiki/Spoofing_attack">spoofing</a> attacks.
Both online and offline use cases might be susceptible to these types of
attacks, where an adversary intercepts, modifies, re-uses, and/or replicates the
[=verifiable credential=] data during transmission or storage.
        </p>
        <h4>Man-in-the-Middle (MITM) Attack</h4>

        <p>
A [=verifier=] might need to ensure it is the intended recipient of a
[=verifiable presentation=] and not the target of a
<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack">
man-in-the-middle attack</a>. Some <a href="#securing-mechanisms">securing
mechanisms</a>, like [[VC-JOSE-COSE]] or [[VC-DATA-INTEGRITY]], provide an
option to specify the intended audience or domain of a [=presentation=],
which can help reduce this risk.
        </p>
        <p>
Alternate approaches such as token binding [[RFC8471]], which ties the request
for a [=verifiable presentation=] to the response, can secure the protocol.
Any unsecured protocol is susceptible to man-in-the-middle attacks.
        </p>
        <h4>Replay Attack</h4>

        <p>
A [=verifier=] might wish to ensure that a [=verifiable presentation=] is
not used more than a certain number of times. For example, a <a>verifiable
credential</a> representing an event ticket, might allow entry to multiple
individuals if presented multiple times, undermining the purpose of the ticket
from the perspective of its issuer. To prevent against such attacks,
[=holders=] can make use of techniques such as including a
<a href="https://en.wikipedia.org/wiki/Cryptographic_nonce">nonce</a> during
presentation, or adding an expiry timestamp to reduce the window of attack.
        </p>
        <h4>Spoofing Attack</h4>

        <p>
A [=verifier=] has a vested interest in knowing that a [=holder=] is
authorized to present the claims inside of a [=verifiable presentation=].
While the data model outlines the structure and data elements necessary for a
[=verifiable credential=], it does not include a mechanism to ascertain the
authorization of presented [=credentials=]. To address this concern,
implementers might need to explore supplementary methods, such as binding
[=verifiable credentials=] to strong authentication mechanisms or using
additional attributes in [=verifiable presentations=]
to enable proof of control.
        </p>
      </section>
      <section class="informative">
        <h3>Bundling Dependent Claims</h3>

        <p>
It is considered best practice for [=issuers=] to atomize information in a
[=credential=], or use a signature scheme that allows for selective
disclosure. In the case of atomization, if it is not done securely by the
[=issuer=], the [=holder=] might bundle together different
[=credentials=] in a way that was not intended by the [=issuer=].
        </p>

        <p>
For example, a university might issue two [=verifiable credentials=] to a
person, each containing two [=properties=], which must be taken together
to designate the "role" of that person in a given "department", such as "Staff
Member" in the "Department of Computing", or "Post Graduate Student" in the
"Department of Economics". If these [=verifiable credentials=] are atomized
to put only one of these [=properties=] into each [=credential=] , then
the university would issue four [=credentials=] to the person, each
containing one of the following designations: "Staff Member", "Post Graduate
Student", "Department of Computing", and "Department of Economics". The
[=holder=] might then transfer the "Staff Member" and "Department of
Economics" [=verifiable credentials=] to a [=verifier=], which together
would comprise a false [=claim=].
        </p>
      </section>

      <section class="informative">
        <h3>Highly Dynamic Information</h3>

        <p>
When [=verifiable credentials=] are issued for highly dynamic information,
implementers should ensure the validity periods are set appropriately. Validity
periods longer than the timeframe where the [=verifiable credential=] is
meant for use might create exploitable security vulnerabilities. Validity
periods shorter than the timeframe where the information expressed by the
[=verifiable credential=] is expected to be used creates a burden on
[=holders=] and [=verifiers=]. It is therefore important to set validity
periods for [=verifiable credentials=] that are appropriate to the use case
and the expected lifetime for the information contained in the
[=verifiable credential=].
        </p>
      </section>

      <section class="informative">
        <h3>Device Theft and Impersonation</h3>

        <p>
When [=verifiable credentials=] are stored on a device and that
device is lost or stolen, it might be possible for an attacker to gain access
to systems using the victim's [=verifiable credentials=]. Ways to mitigate
this type of attack include:
        </p>

        <ul>
          <li>
Enabling password, pin, pattern, or biometric screen unlock protection on the
device.
          </li>
          <li>
Enabling password, biometric, or multi-factor authentication for the
[=credential=] [=repository=].
          </li>
          <li>
Enabling password, biometric, or multi-factor authentication when accessing
cryptographic keys.
          </li>
          <li>
Using a separate hardware-based signature device.
          </li>
          <li>
All or any combination of the above.
          </li>
        </ul>

        <p>
Furthermore, instances of impersonation can manifest in various forms, including
situations where an [=entity=] attempts to disavow their actions. Elevating
the level of trust and security within the realm of <a>verifiable
credentials</a> entails more than just averting impersonation; it involves the
implementation of non-repudiation mechanisms. These mechanisms solidify an
[=entity=]'s responsibility for their actions or transactions, thereby
reinforcing accountability and deterring malicious behaviors. The attainment of
non-repudiation is a multifaceted endeavor, encompassing an array of techniques
ranging from <a href="#securing-mechanisms">securing mechanisms</a>, proofs of
possession, and authentication schemes in a variety of protocols designed to
foster trust and reliability.
        </p>
      </section>
      <section class="informative">
        <h3>Acceptable Use</h3>

        <p>
Ensuring that there is alignment between an [=entity=]'s actions, such as
[=presentation=], and the intended purpose of those actions, is of
importance. It involves having the authorization to make use of <a>verifiable
credentials</a> as well as using [=credentials=] in a manner that adheres to
their designated scope(s) and objective(s). Two critical aspects that arise
within this context are <i>Unauthorized Use</i> and <i>Inappropriate Use</i>.
        </p>
        <h4>Unauthorized Use</h4>
        <p>
Any attempt by entities to make use of [=verifiable credentials=] and
[=verifiable presentations=] outside of their intended use can be seen as
unauthorized. One class of unauthorized use is a <i>confidentiality
violation</i>. Consider an example where a [=holder=] shares a <a>verifiable
presentation</a> with a [=verifier=] to establish their age and residency
status. If the [=verifier=] then proceeds to exploit the [=holder's=] data
without proper consent, such as by selling the data to a data broker, that would
constitute an unauthorized use of the data, violating an expectation of privacy
that the [=holder=] might have in the transaction.
        </p>
        <p>
Similarly, an [=issuer=] could make use of a
<a href="#terms-of-use">termsOfUse</a> property to stipulate how and when a
credential might be used. A [=holder=] using credentials outside of the
scopes defined in the `termsOfUse` would be considered unauthorized
use.
        </p>
        <p class="note">
Further study is required to determine how a [=holder=] can assert and
enforce authorized use of their data after [=presentation=].
        </p>
        <h4>Inappropriate Use</h4>
        <p>
While valid cryptographic signatures and successful status checks signify the
reliability of [=credentials=], they do not signify that all
[=credentials=] are interchangeable for all contexts. It is crucial that
[=verifiers=] also <a href="#validation-0">validate</a> any claims which
might be relevant, considering the source and nature of the claim as well as
privilege or service for which the credential is presented.
        </p>
        <p>
For instance, in scenarios where a certified medical diagnosis is required, a
self-asserted [=credential=] carrying the necessary data might not suffice
because it lacks validity from an authoritative medical source. To ensure the
propriety of [=credential=] use, stakeholders are urged to assess the
<a href="#dfn-credential">credential's</a> relevance and authority within the
specific context of their intended application.
        </p>
      </section>
    </section>

    <section class="informative">
      <h2>Accessibility Considerations</h2>

      <p>
There are a number of accessibility considerations implementers should be
aware of when processing data described in this specification. As with
implementation of any web standard or protocol, ignoring accessibility issues
makes this information unusable by a large subset of the population. It is
important to follow accessibility guidelines and standards, such as [[WCAG21]],
to ensure that all people, regardless of ability, can make use of this data.
This is especially important when establishing systems utilizing cryptography,
which have historically created problems for assistive technologies.
      </p>

      <p>
This section details the general accessibility considerations to take into
account when utilizing this data model.
      </p>

      <section class="informative">
        <h3>Data First Approaches</h3>

        <p>
Many physical [=credentials=] in use today, such as government identification
cards, have poor accessibility characteristics, including, but not limited to,
small print, reliance on small and high-resolution images, and no affordances
for people with vision impairments.
        </p>

        <p>
When utilizing this data model to create [=verifiable credentials=], it is
suggested that data model designers use a <em>data first</em> approach. For
example, given the choice of using data or a graphical image to depict a
[=credential=], designers should express every element of the image, such as
the name of an institution or the professional [=credential=], in a
machine-readable way instead of relying on a viewer's interpretation of the
image to convey this information. Using a data first approach is preferred
because it provides the foundational elements of building different interfaces
for people with varying abilities.
        </p>
      </section>
    </section>

    <section class="informative">
      <h2>Internationalization Considerations</h2>

      <p>
Implementers are advised to be aware of a number of internationalization
considerations when publishing data described in this specification.
As with any web standards or protocols implementation, ignoring
internationalization makes it difficult for data to be produced and consumed
across a disparate set of languages and societies, which limits the
applicability of the specification and significantly diminishes its value as a
standard.
      </p>

      <p>
Implementers are strongly advised to read the
<em>Strings on the Web: Language and Direction Metadata</em> document
[[STRING-META]], published by the W3C Internationalization Activity, which
elaborates on the need to provide reliable metadata about text to support
internationalization. For the latest information on internationalization
considerations, implementers are also urged to read the Verifiable Credentials
Implementation Guidelines [[VC-IMP-GUIDE]] document.
      </p>

      <p>
This section outlines general internationalization considerations to take into
account when utilizing this data model and is intended to highlight specific
parts of the <em>Strings on the Web: Language and Direction Metadata</em>
document [[STRING-META]] that implementers might be interested in reading.
      </p>

      <section>
        <h3>Language and Base Direction</h3>

        <p>
Data publishers are strongly encouraged to read the section on
Cross-Syntax Expression in the <em>Strings on the Web: Language and Direction
Metadata</em> document [[STRING-META]] to ensure that the expression of
language and <dfn data-cite="i18n-glossary">base direction</dfn> information is
possible across multiple expression syntaxes, such as [[JSON-LD]], [[JSON]],
and CBOR [[?RFC7049]].
        </p>

        <p>
The general design pattern is to use the following markup template when
expressing a text string that is tagged with a language and, optionally, a
specific base direction.
        </p>

        <pre class="example nohighlight" title="Design pattern for natural language strings">
"[=property=]": {
  "@value": "<span class="highlight">The string value</span>",
  "@language": "`LANGUAGE`"
  "@direction": "`DIRECTION`"
}
        </pre>

        <p>
When the language value object is used in place of a string value, the object
MUST contain a `@value` property whose value is a string, and SHOULD contain a
`@language` property whose value is a string containing a well-formed
`Language-Tag` as defined by [[BCP47]], and MAY contain a `@direction` property
whose value is a [=base direction=] string defined by the `@direction`
attribute in [[JSON-LD]]. The language value object MUST NOT include any other
keys beyond `@value`, `@language`, and `@direction`.
        </p>

        <p>
Using the design pattern above, the following example expresses the title of a
book in the English language without specifying a text direction.
        </p>

        <pre class="example nohighlight" title="Expressing natural language text as English">
"title": {
  "@value": "<span class="highlight">HTML and CSS: Designing and Creating Websites</span>",
  "@language": "`en`"
}
        </pre>

        <p>
The next example uses a similar title expressed in the Arabic language with a
base direction of right-to-left.
        </p>

        <pre class="example nohighlight" title="Arabic text with a base direction of right-to-left">
"title": {
  "@value": "<span class="highlight" dir="rtl" lang="ar">HTML و CSS: تصميم و إنشاء مواقع الويب</span>",
  "@language": "`ar`",
  "@direction": "`rtl`"
}
        </pre>

        <p class="note">
The text above would most likely be rendered incorrectly as left-to-right
without the explicit expression of language and direction because many systems
use the first character of a text string to determine its [=base direction=].
        </p>

        <p>
Multiple language value objects MAY be provided as an array value for the
property:
        </p>

        <pre class="example nohighlight" title="Multiple language texts provided for title">
"title": [
  {
    "@value": "<span class="highlight">HTML and CSS: Designing and Creating Websites</span>",
    "@language": "`en`"
  },
  {
    "@value": "<span class="highlight" dir="rtl" lang="ar">HTML و CSS: تصميم و إنشاء مواقع الويب</span>",
    "@language": "`ar`",
    "@direction": "`rtl`"
  }
]
        </pre>
      </section>

      <section class="substantive">
        <h3>Providing Default Language and Direction</h3>

        <p>
The language and base direction of each natural language string property value
SHOULD be provided, either via the language value structure for each property
value, or via a default language and base direction for all values in the entire
credential. Using the per-value language value structure is preferred, because
using document defaults can result in a requirement that downstream processors
perform JSON-LD expansion-based transformation which is otherwise optional. See
the <a data-cite="JSON-LD#string-internationalization">
String Internationalization</a> section of the [[JSON-LD]] specification for
more information. Natural language string values that do not have a language
associated with them SHOULD be treated as if the language value is `undefined`
(language tag "`und`"). Natural language string values that do not have a base
direction associated with them SHOULD be treated as if the direction value is
"`auto`".
        </p>
      </section>

      <section class="informative">
        <h3>Complex Language Markup</h3>

        <p>
When a single natural language string contains multiple languages or
annotations, the contents of the string might require additional structure or
markup in order to be presented correctly. It is possible to use markup
languages, such as HTML, to label spans of text in different languages or to
supply string-internal markup needed for proper display of <a>bidirectional
text</a>. It is also possible to use the `rdf:HTML` datatype to
encode such values accurately in JSON-LD.
        </p>

        <p>
Despite the ability to encode information as HTML, implementers are strongly
discouraged from doing this because it:
        </p>

        <ul>
          <li>
Requires some version of an HTML processor, which increases the burden of
processing language and base direction information.
          </li>
          <li>
Increases the security attack surface when utilizing this data model because
blindly processing HTML could result in executing a `script` tag that
an attacker injected at some point during the data production process.
          </li>
        </ul>

        <p>
If implementers feel they must use HTML, or other markup languages capable of
containing executable scripts, to address a specific use case, they are advised
to analyze how an attacker would use the markup to mount injection attacks
against a consumer of the markup and then deploy mitigations against the
identified attacks.
        </p>
      </section>

    </section>

    <section class="appendix informative">
      <h2>Validation</h2>

      <p>
While this specification does not provide conformance criteria for the process
of the [=validation=] of [=verifiable credentials=] or
[=verifiable presentations=], readers might be curious about how the
information in this data model is expected to be utilized by [=verifiers=]
during the process of [=validation=]. This section captures a selection of
conversations held by the Working Group related to the expected usage of the
data fields in this specification by [=verifiers=].
      </p>

      <section class="informative">
        <h3>Credential Type</h3>

        <p>
When a [=verifier=] requests one or more [=verifiable credentials=]
from a [=holder=], they can specify the type of credential(s) that they would
like to receive. The type of a credential is expressed via the
<a href="#types">type</a> property. A [=verifiable credential=] of a specific
type is expected to contain specific [=properties=] that can be used to
determine whether or not the [=presentation=] meets a set of processing rules
that the [=verifier=] is executing. By requesting
[=verifiable credentials=] of a particular `type`, the
[=verifier=] is able to gather specific information from the [=holder=],
which originated  with the [=issuer=] of each [=verifiable credential=],
that will enable it to determine the next stage of an interaction with a
[=holder=].
        </p>
      </section>

      <section class="informative">
        <h3>Credential Subject</h3>

        <p>
In the [=verifiable credentials=] presented by a [=holder=], the value
associated with the `id` [=property=] for each
`credentialSubject` is expected to identify a [=subject=] to the
[=verifier=]. If the [=holder=] is also the [=subject=], then
the [=verifier=] could authenticate the [=holder=] if they have
public key metadata related to the [=holder=]. The [=verifier=] could then
authenticate the [=holder=] using a signature generated by the [=holder=]
contained in the [=verifiable presentation=]. The `id`
[=property=] is optional. [=Verifiers=] could use other [=properties=]
in a [=verifiable credential=] to uniquely identify a [=subject=].
        </p>

        <p class="note">
For information on how authentication and WebAuthn might work with
[=verifiable credentials=], see the Verifiable Credentials Implementation
Guidelines [[VC-IMP-GUIDE]] document.
        </p>

      </section>

      <section class="informative">
        <h3>Issuer</h3>

        <p>
The value associated with the `issuer` [=property=] is expected
to identify an [=issuer=] that is known to and trusted by the
[=verifier=].
        </p>

        <p>
Metadata related to the `issuer` [=property=] is available to the
[=verifier=] through the <a href="#verification">verification
algorithm</a> as defined in Section <a href="#verification"></a>.
This metadata includes identification of the verified controller of the
verification method used by the securing mechanism to secure each <a>verifiable
credential</a> or [=verifiable presentation=], of which the controller is
typically the respective `issuer` or `holder`.
        </p>

        <p>
Some ecosystems might have more complex relationships between [=issuers=]
and controllers of verification methods and might use lists of verified
issuers in addition to, or instead of, the mapping described above.
        </p>
      </section>

      <section class="informative">
        <h4>Holder</h4>
        <p>
The value associated with the `holder` [=property=] is expected
to be usable to identify the [=holder=] to the [=verifier=].
        </p>
        <p>
Often relevant metadata about the [=holder=], as identified by the value of
the `holder` [=property=], is available to, or retrievable by, the
[=verifier=]. For example, a [=holder=] can publish information containing
the verification material used to secure
[=verifiable presentations=]. This metadata is expected to be used when
checking proofs on [=verifiable presentations=]. Some cryptographic
identifiers contain all necessary metadata in the identifier itself. In those
cases, no additional metadata is required. Other identifiers use verifiable data
registries where such metadata is automatically published for use by
[=verifiers=], without any additional action by the [=holder=].
        </p>
        <p>
See the <a data-cite="VC-IMP-GUIDE/#subject-holder-relationships"></a> and
<a data-cite="VC-USE-CASES#user-tasks"></a> for additional examples related to
[=subject=] and [=holder=].
        </p>

        <p class="note">
Validation is the process by which verifiers apply business rules to
evaluate the propriety of a particular use of a [=verifiable credential=].
        </p>
        <ul>
          <li>
          </li>
        </ul>
        <p>
A [=verifier=] might need to validate a given [=verifiable presentation=]
against complex business rules; for example, the verifier might need confidence
that the [=holder=] is the same entity as a [=subject=] of a <a>verifiable
credential</a>. In such a situation, the following factors can provide a
[=verifier=] with reasonable confidence that the claims expressed regarding
that identifier, in included [=verifiable credentials=], are, in fact, about
the current presenter:
        </p>
        <ul>
          <li>
The [=verifiable presentation=] is secured, using a mechanism the
[=verifier=] trusts to protect the integrity of the content.
          </li>
          <li>
The [=verifiable presentation=] includes one or more <a>verifiable
credentials</a> that are secured, using a mechanism the [=verifier=] trusts
to protect the integrity of the content.
          </li>
          <li>
The identifier in the `holder` property of the [=verifiable presentation=]
and at least one identifier property of at least one object in the
`credentialSubject` array are the same.
          </li>
          <li>
That common identifier can be used to discover or derive the verification
material used to verify the integrity of that [=verifiable presentation=].
          </li>
        </ul>
      </section>

      <section class="informative">
        <h3>Issuance Date</h3>

        <p>
The `validFrom` is expected to be within an expected range for the
[=verifier=]. For example, a [=verifier=] can check that the start of
the validity period for a [=verifiable credential=] is not in the future.
        </p>
      </section>

      <section class="informative">
        <h3>Proofs (Signatures)</h3>

        <p>
The cryptographic mechanism used to prove that the information in a
[=verifiable credential=] or [=verifiable presentation=] was not tampered
with is called a <em>proof</em>. There are many types of cryptographic proofs
including, but not limited to, digital signatures and zero-knowledge proofs. In
general, when verifying proofs, implementations are expected to ensure:
        </p>

        <ul>
          <li>
The proof is available in the form of a known proof suite.
          </li>
          <li>
All required proof suite [=properties=] are present.
          </li>
          <li>
The proof suite [=verification=] algorithm, when applied to the data, results
in an acceptable proof.
          </li>
        </ul>

        <p>
Some proofs are digital signatures. In general, when verifying digital
signatures, implementations are expected to ensure:
        </p>

        <ul>
          <li>
Acceptably recent metadata regarding the public key associated with the
signature is available. For example, the metadata might include
[=properties=] related to validity periods, key owner, or key purpose.
          </li>
          <li>
The key is not suspended, revoked, or expired.
          </li>
          <li>
The cryptographic signature is expected to verify.
          </li>
          <li>
If the cryptographic suite expects a `proofPurpose` [=property=],
it is expected to exist and be a valid value, such as
`assertionMethod`.
          </li>
        </ul>

        <p class="note">
The digital signature provides a number of protections, other than tamper
resistance, which are not immediately obvious. For example, a Linked Data
Signature `created` [=property=] establishes a date and time
before which the [=credential=] should not be considered [=verified=],
distinct from the validity period of the credential. This property describes the
validity of the proof, not of the credential.
<br/><br/>
The `verificationMethod` [=property=] specifies, for example, the
public key that can be used to verify the digital signature. Dereferencing a
public key URL reveals information about the controller of the key, which can
be checked against the issuer of the [=credential=]. The
`proofPurpose` [=property=] clearly expresses the purpose for
the proof and ensures this information is protected by the signature. A proof is
typically attached to a [=verifiable presentation=] for authentication
purposes and to a [=verifiable credential=] as a method of assertion.
        </p>
      </section>

      <section class="informative">
        <h3>Validity Periods</h3>

        <p>
The [=verifier=] expects that the `validFrom` and
`validUntil` properties will be within a certain range. For example,
a [=verifier=] can check that the end of the validity period of a
[=verifiable credential=] is not in the past. Because some credentials can be
useful for secondary purposes even if their original validity period has
expired, validity period, as expressed using the `validFrom` and
`validUntil` properties, is always considered a component of
validation, which is performed <em>after</em> verification.
        </p>
      </section>

      <section class="informative">
        <h3>Status</h3>

        <p>
If the `credentialStatus` property is available, the status of a
[=verifiable credential=] is expected to be evaluated by the [=verifier=]
according to the `credentialStatus` [=type=] definition for the
[=verifiable credential=] and the [=verifier's=] own status evaluation
criteria. For example, a [=verifier=] can ensure the status of the
[=verifiable credential=] is not "withdrawn for cause by the [=issuer=]".
        </p>
      </section>

      <section class="informative">
        <h3>Schema</h3>

        <p>
If the `credentialSchema` property is available, the schema of a
[=verifiable credential=] is expected to be evaluated by the [=verifier=]
according to the `credentialSchema` [=type=] definition for the
[=verifiable credential=] and the [=verifier's=] own schema evaluation
criteria. For example, if the `credentialSchema`'s `type`
value is [[?VC-JSON-SCHEMA]], then a [=verifier=] can ensure a credential's
data is valid against the given JSON Schema.
        </p>
      </section>

      <section class="informative">
        <h3>Fitness for Purpose</h3>

        <p>
Fitness for purpose is about whether the custom [=properties=] in the
[=verifiable credential=] are appropriate for the [=verifier's=] purpose.
For example, if a [=verifier=] needs to determine whether a [=subject=] is
older than 21 years of age, they might rely on a specific `birthdate`
[=property=], or on more abstract [=properties=], such as
`ageOver`.
        </p>

        <p>
The [=issuer=] is trusted by the [=verifier=] to make the [=claims=] at
hand. For example, a franchised fast food restaurant location trusts the
discount coupon [=claims=] made by the corporate headquarters of the
franchise. Policy information expressed by the [=issuer=] in the
[=verifiable credential=] should be respected by [=holders=] and
[=verifiers=] unless they accept the liability of ignoring the policy.
        </p>
      </section>
    </section>

    <section class="appendix">
      <h2>Contexts, Vocabularies, Types, and Credential Schemas</h2>

      <section class="normative">
        <h3>Base Context</h3>

        <p class="issue" title="(AT RISK) Hash values might change during Candidate Recommendation">
This section lists cryptographic hash values that might change during the
Candidate Recommendation phase based on implementer feedback that requires
the referenced files to be modified.
<br><br>
The Working Group is expecting all of the terms and URLs supplied in the
JSON-LD Context to be either stabilized, or removed, before the publication of
this specification as a Proposed Recommendation. While that means that this
specification could be delayed if dependencies such as [[?VC-DATA-INTEGRITY]],
[[?VC-JOSE-COSE]], SD-JWT, [[?VC-JSON-SCHEMA]], or status list
do not enter the Proposed Recommendation phase around the same time frame, the
Working Group is prepared to remove the dependencies if an undue burden is
placed on transitioning to the Recommendation phase. This is a calculated
risk that the Working Group is taking and has a mitigation strategy in place
to ensure the timely transition of this specification to a Recommendation.
        </p>
        <p>
Implementations MUST treat the base context value, located at
`https://www.w3.org/ns/credentials/v2`, as already retrieved;
the following value is the SHA-384 digest of the resource
computed and encoded according to the [[SRI]] definition of `digest`:
<strong>`vxRgTREj3/ZmDabpiTX+Au4UXY8GDhyCSFNw+UQtdtISDyO/znDUY+FTg8rNsGXJ`</strong>.
It is strongly advised that all JSON-LD Context URLs used by an
application utilize the same mechanism, or a functionally equivalent mechanism,
to ensure end-to-end security. Implementations are expected to throw errors
if a cryptographic hash value for a resource does not match the expected hash
value.
        </p>
        <p>
Implementations that apply the base context above, as well as other contexts
and values in any `@context` property, during operations such as
<a href="https://www.w3.org/TR/json-ld11-api/#expansion-algorithm">
JSON-LD Expansion</a> or
<a href="https://www.w3.org/TR/json-ld11/#serializing-deserializing-rdf">
transformation to RDF</a>, are expected to do so without experiencing any
errors. If such operations are performed and result in an error,
the [=verifiable credential=] or [=verifiable presentation=] MUST result
in a verification failure.
        </p>
        <p>
It is possible to confirm the SHA-384 digest above by running the following
command from a modern Unix command interface line:
`curl -s https://www.w3.org/ns/credentials/v2 | openssl dgst -sha384 -binary | openssl base64 -A`
        </p>
        <p>
More details regarding this hash encoding method can be found in the <a
href="https://www.w3.org/TR/SRI/#integrity-metadata">integrity metadata</a>
section of [[SRI]].
        </p>
        <p class="note" title="See errata if hash value changes are detected">
It is extremely unlikely that the files that have associated cryptographic hash
values in this specification will change. However, if critical errata are
found in the specification and corrections are required to ensure
ecosystem stability the cryptographic hash values might change. As such, the
HTTP cache times for the files are not set to infinity and implementers are
advised to check for errata if a cryptographic hash value change is detected.
        </p>
        <p>
This section serves as a reminder of the importance of ensuring that, when
verifying [=verifiable credentials=] and [=verifiable presentations=], the
[=verifier=] has information that is consistent with what the [=issuer=]
or [=holder=] had when securing the [=credential=] or [=presentation=].
This information might include at least:
        </p>
        <ol>
          <li>
The contents of the credential itself, which is secured in
[=verifiable credentials=] and [=verifiable presentations=] by using
mechanisms such as [[VC-JOSE-COSE]] and [[VC-DATA-INTEGRITY]].
          </li>
          <li>
The content in a credential whose meaning depends on a link to an external URL,
such as a JSON-LD Context, which can be secured by using a local static copy
or a cryptographic digest of the file.
          </li>
        </ol>
        <p>
Verifiers are warned that other data that is referenced from within a
credential, such as resources that are linked to via URLs, are not
cryptographically protected by default. It is considered a best practice to
ensure that the same sorts of protections are provided for any URL that is
critical to the security of the [=verifiable credential=] through the use of
permanently cached files and/or cryptographic hashes. See the
<a data-cite="?vc-imp-guide/#content-integrity">Content Integrity</a>
section of the Verifiable Credential Implementation Guide for further
information. Ultimately, knowing the cryptographic digest of any linked external
content enables a [=verifier=] to confirm that the content is the same
as what the [=issuer=] or [=holder=] intended.
        </p>
      </section>

      <section class="normative">
        <h3>Vocabularies</h3>

        <p class="issue" title="(AT RISK) URL values might change during Candidate Recommendation">
This section lists URL values that might change during the Candidate
Recommendation phase based on migration of documents to time-stamped locations,
migration of documents to the W3C Technical Reports namespace, and/or
implementer feedback that requires the referenced URLs to be modified.
        </p>

        <p>
Implementations that depend on RDF vocabulary processing MUST ensure that the
following vocabulary URLs used in the base context ultimately resolve to the
following files, which are normative. Other semantically equivalent
serializations of the vocabulary files MAY be used by implementations.
Cryptographic hashes are provided for all content to ensure that developers can
verify that the contents of each file are correct.
        </p>

        <table class="simple">
          <thead>
            <tr>
              <th>URL and Media Type</th>
              <th>Content and Hashes</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>
https://www.w3.org/2018/credentials#<br>
`application/ld+json`
              </td>
              <td>
https://www.w3.org/2018/credentials/index.jsonld<br><br>
sha256: `z52TgKqh2nqTCuACI8lCvhRdjwxQjeVmuOMCDCEijq4=`<br><br>
sha3-512: `m8Ss+jgZiyL2Ws/ICJcWjHFd9PccJWsXPvMatBOhrH<wbr>
h0qCBrzfgO2zO1OQQbTL7zoPgLseIbcxJJpunD2bkoRA==`
              </td>
            </tr>
            <tr>
              <td>
https://w3id.org/security#<br>
`application/ld+json`
              </td>
              <td>
https://w3c.github.io/vc-data-integrity/vocab/security/vocabulary.jsonld<br><br>
sha256: `LEaoTyf796eTaSlYWjfPe3Yb+poCW9TjWYTbFDmC0tc=`<br><br>
sha3-512: `f4DhJ3xhT8nT+GZ8UUZi4QC+HT//wXE2fRTgUP4UNw<wbr>
e4kvel2PFfd6jcofHBm9BjwEiGzVFGv4K+fFTKXRD2NA==`
              </td>
            </tr>
          </tbody>
        </table>

        <p>
It is possible to confirm the cryptographic digests listed above by running the
following command from a modern Unix command interface line:
`curl -sL -H "Accept: &lt;MEDIA_TYPE>" &lt;DOCUMENT_URL> | openssl dgst -&ltDIGEST_ALGORITHM> -binary | openssl base64 -nopad -a`
        </p>

        <p class="note"
            title="schema.org changes regularly, but is considered stable">
Implementers and document authors might note that cryptographic digests for
`schema.org` are not provided. This is because the `schema.org` vocabulary
undergoes regular changes; any digest provided would be out of date within
weeks of publication. The Working Group discussed this concern and concluded
that the vocabulary terms from `schema.org`, that are used by this
specification, have been stable for years and are highly unlikely to change in
their semantic meaning.
        </p>

        <p>
The following base classes are defined in this specification for processors
and other specifications that benefit from such definitions:
        </p>

        <table class="simple">
          <thead>
            <tr>
              <th>Base Class</th>
              <th>Purpose</th>
            </tr>
          </thead>
          <tbody>
            <tr id="bc-credential-evidence">
              <td>
`CredentialEvidence`
              </td>
              <td>
Serves as a superclass for specific evidence types that are placed into the
<a href="#evidence">evidence</a> property. <span class="issue atrisk">This
superclass is at risk and will be removed if at least two independent
implementations for the superclass are not identified by the end of the
Candidate Recommendation phase.</span>
              </td>
            </tr>
            <tr id="bc-credential-schema">
              <td>
`CredentialSchema`
              </td>
              <td>
Serves as a superclass for specific schema types that are placed into the
<a href="#data-schemas">credentialSchema</a> property.
              </td>
            </tr>
            <tr id="bc-credential-status">
              <td>
`CredentialStatus`
              </td>
              <td>
Serves as a superclass for specific credential status types that are placed into
the <a href="#status">credentialStatus</a> property.
              </td>
            </tr>
            <tr id="bc-confidence-method">
              <td>
`ConfidenceMethod`
              </td>
              <td>
Serves as a superclass for specific confidence method types that are placed into
the `confidenceMethod` property.
<span class="issue atrisk">This superclass is at risk and will be removed if
at least two independent implementations for the superclass are not identified
by the end of the Candidate Recommendation phase.
</span>
              </td>
            </tr>
            <tr id="bc-refresh-service">
              <td>
`RefreshService`
              </td>
              <td>
Serves as a superclass for specific refresh service types that are placed into
the <a href="#refreshing">credentialRefresh</a> property.
<span class="issue atrisk">This superclass is at risk and will be removed if
at least two independent implementations for the superclass are not identified
by the end of the Candidate Recommendation phase.
</span>
              </td>
            </tr>
            <tr id="bc-render-method">
              <td>
`RenderMethod`
              </td>
              <td>
Serves as a superclass for specific render method types that are placed into
the `renderMethod` property.
<span class="issue atrisk">This superclass is at risk and will be removed if
at least two independent implementations for the superclass are not identified
by the end of the Candidate Recommendation phase.
</span>
              </td>
            </tr>
            <tr id="bc-terms-of-use">
              <td>
`TermsOfUse`
              </td>
              <td>
Serves as a superclass for specific terms of use types that are placed into
the <a href="#terms-of-use">termsOfUse</a> property.
<span class="issue atrisk">This superclass is at risk and will be removed if
at least two independent implementations for the superclass are not identified
by the end of the Candidate Recommendation phase.
</span>
              </td>
            </tr>
          </tbody>
        </table>

      </section>

      <section>
        <h3>Datatypes</h3>
        <p>
          This section defines datatypes that are used by this specification.
        </p>

        <section>
            <h4>The `sriString` Datatype</h4>

            <p>
The string provides the integrity information for a resource using the method
specified in the [[SRI]] specification.
            </p>

            <p>
The `sriString` datatype is defined as follows:
            </p>

            <dl>
              <dt>The URL denoting this datatype</dt>
              <dd>`https://www.w3.org/2018/credentials#sriString`</dd>
              <dt>The lexical space</dt>
              <dd>
See the <a href="https://www.w3.org/TR/SRI/#the-integrity-attribute">ABNF
grammar</a>, defining the `integrity` attribute in the [[SRI]] specification,
for the restrictions on the string format.
              </dd>
              <dt>The value space</dt>
              <dd>
A (possibly empty) list of <i>(alg,val)</i> pairs, where <i>alg</i> identifies a
hash function, and <i>val</i> is an integer as a standard mathematical concept.
              </dd>
              <dt>The lexical-to-value mapping</dt>
              <dd>
Any element of the lexical space is mapped to the value space by following the
<a href="https://www.w3.org/TR/SRI/#parse-metadata">parse metadata algorithm</a>
based on the <a href="https://www.w3.org/TR/SRI/#the-integrity-attribute">ABNF
grammar</a> in the [[SRI]] specification.
              </dd>
              <dt>The canonical mapping</dt>
              <dd>
The canonical mapping consists of the lexical-to-value mapping.
              </dd>
            </dl>
        </section>


      </section>

      <section class="informative">
        <h3>Differences between Contexts, Types, and CredentialSchemas</h3>

        <p>
The [=verifiable credential=] and [=verifiable presentation=] data models
leverage a variety of underlying technologies including [[JSON-LD]] and
[[?VC-JSON-SCHEMA]]. This section will provide a comparison of the
`@context`, `type`, and `credentialSchema`
properties, and cover some of the more specific use cases where it is possible
to use these features of the data model.
        </p>

        <p>
The `type` property is used to uniquely identify the type of the
[=verifiable credential=] in which it appears, i.e., to indicate which set of
claims the [=verifiable credential=] contains. This property, and the value
`VerifiableCredential` within the set of its values, are mandatory.
Whilst it is good practice to include one additional value depicting the unique
subtype of this [=verifiable credential=], it is permitted to either omit or
include additional type values in the array. Many verifiers will request a
[=verifiable credential=] of a specific subtype, then omitting the subtype
value could make it more difficult for verifiers to inform the holder which
[=verifiable credential=] they require. When a [=verifiable credential=]
has multiple subtypes, listing all of them in the `type`
property is sensible. The usage of the `type` property in a
[[JSON-LD]] representation of a [=verifiable credential=] enables to enforce
the semantics of the [=verifiable credential=] because the machine is able to
check the semantics. With [[JSON-LD]], the technology is not only describing the
categorization of the set of claims, the technology is also conveying the
structure and semantics of the sub-graph of the properties in the graph. In
[[JSON-LD]], this represents the type of the node in the graph which is why some
[[JSON-LD]] representations of a [=verifiable credential=] will use the
`type` property on many objects in the [=verifiable credential=].
        </p>

        <p>
The primary purpose of the `@context` property, from a [[JSON-LD]]
perspective, is to convey the meaning of the data and term definitions of the
data in a [=verifiable credential=], in a machine readable way. The
`@context` property is used to map the globally unique URLs for
properties in [=verifiable credentials=] and [=verifiable presentations=]
into short-form alias names, making [[JSON-LD]] representations more
human-friendly to read. From a [[JSON-LD]] perspective, this mapping also allows
the data in a [=credential=] to be modeled in a network of machine-readable
data, by enhancing how the data in the [=verifiable credential=] or
[=verifiable presentation=] relates to a larger machine-readable data graph.
This is useful for telling machines how to relate the meaning of data to other
data in an ecosystem where parties are unable to coordinate. This property, with
the first value in the set being
`https://www.w3.org/ns/credentials/v2`, is mandatory.
        </p>

        <p>
Since the `@context` property is used to map data to a graph
data model, and the `type` property in [[JSON-LD]] is used to
describe nodes within the graph, the `type` property becomes
even more important when using the two properties in combination. For example,
if the `type` property is not included within the resolved
`@context` resource using [[JSON-LD]], it could lead to claims being
dropped and/or their integrity no longer being protected during production and
consumption of the [=verifiable credential=]. Alternatively, it could lead to
errors being raised during production or consumption of a <a>verifiable
credential</a>. This will depend on the design choices of the implementation and
both paths are used in implementations today, so it's important to pay attention
to these properties when using a [[JSON-LD]] representation of a <a>verifiable
credential</a> or [=verifiable presentation=].
        </p>

        <p>
The primary purpose of the `credentialSchema` property is to define
the structure of the [=verifiable credential=], and the datatypes for the
values of each property that appears. A `credentialSchema` is useful
for defining the contents and structure of a set of claims in a <a>verifiable
credential</a>, whereas [[JSON-LD]] and a `@context` in a
[=verifiable credential=] are best used only for conveying the semantics and
term definitions of the data, and can be used to define the structure of the
[=verifiable credential=] as well.
        </p>

        <p>
While it is possible to use some [[JSON-LD]] features to allude to the contents
of the [=verifiable credential=], it's not generally suggested to use
`@context` to constrain the data types of the data model. For
example, `"@type": "@json"` is useful for leaving the semantics
open-ended and not strictly defined. This can be dangerous if the implementer is
looking to constrain the data type of the claims in the
[=credential=], and is expected not to be used.
          </p>

        <p>
When the `credentialSchema` and `@context` properties
are used in combination, both producers and consumers can be more confident
about the expected contents and data types of the [=verifiable credential=]
and [=verifiable presentation=].
        </p>
      </section>
    </section>

    <section class="appendix informative">
      <h2>IANA Considerations</h2>

      <p>
This section will be submitted to the Internet Engineering Steering Group (IESG)
for review, approval, and registration with IANA.
      </p>

      <section id="vc-ld-media-type">
        <h2>application/vc+ld+json</h2>
        <p>
This specification registers the `application/vc+ld+json` Media Type
specifically for identifying documents conforming to the Verifiable Credentials
format.
        </p>
        <table>
          <tr>
            <td>Type name: </td>
            <td>application</td>
          </tr>
          <tr>
            <td>Subtype name: </td>
            <td>vc+ld+json</td>
          </tr>
          <tr>
            <td>Required parameters: </td>
            <td>None</td>
          </tr>
          <tr>
            <td>Encoding considerations: </td>
            <td>
Resources that use the "`application/vc+ld+json`" Media Type are
required to conform to all of the requirements for the
"`application/ld+json`" Media Type and are therefore subject to the
same encoding considerations specified in Section 11 of [[RFC7159]].
            </td>
          </tr>
          <tr>
            <td>Security considerations: </td>
            <td>As defined in this specification.</td>
          </tr>
          <tr>
            <td>Contact: </td>
            <td>
W3C Verifiable Credentials Working Group
<a href="mailto:public-vc-wg@w3.org">public-vc-wg@w3.org</a>
            </td>
          </tr>
        </table>

        <p>
Note that while the Verifiable Credentials format uses JSON-LD conventions,
there are a number of constraints and additional requirements for Verifiable
Credential implementations that justify the use of a specific media type.
        </p>

        <p>
This media type can be used for credentials secured using an
[=enveloping proof=].
        </p>
        <p>
A [[JSON-LD]] context is expected to be present in the body of the document, and
as indicated by the presence of `ld+json` in the media type, the credential is
expected to be a valid
<a href="https://www.w3.org/TR/json-ld11/#dfn-json-ld-document">JSON-LD
document</a>.
        </p>
      </section>

      <section id="vp-ld-media-type">
        <h2>application/vp+ld+json</h2>
        <p>
This specification registers the `application/vp+ld+json` Media
Type specifically for identifying documents conforming to the Verifiable
Presentations format.
        </p>
        <table>
          <tr>
            <td>Type name: </td>
            <td>application</td>
          </tr>
          <tr>
            <td>Subtype name: </td>
            <td>vp+ld+json</td>
          </tr>
          <tr>
            <td>Required parameters: </td>
            <td>None</td>
          </tr>
          <tr>
            <td>Encoding considerations: </td>
            <td>
Resources that use the "`application/vp+ld+json`" Media Type are
required to conform to all of the requirements for the
"`application/ld+json`" Media Type and are therefore subject to the
same encoding considerations specified in Section 11 of [[RFC7159]].
            </td>
          </tr>
          <tr>
            <td>Security considerations: </td>
            <td>As defined in this specification.</td>
          </tr>
          <tr>
            <td>Contact: </td>
            <td>
W3C Verifiable Credentials Working Group
<a href="mailto:public-vc-wg@w3.org">public-vc-wg@w3.org</a>
            </td>
          </tr>
        </table>

        <p>
Note that while the Verifiable Credentials format uses JSON-LD conventions,
there are a number of constraints and additional requirements for Verifiable
Credential implementations that justify the use of a specific media type.
        </p>

        <p>
This media type can be used for presentations secured using an
[=enveloping proof=].
        </p>
        <p>
A [[JSON-LD]] context is expected to be present in the body of the document, and
as indicated by the presence of `ld+json` in the media type, the credential is
expected to be a valid
<a href="https://www.w3.org/TR/json-ld11/#dfn-json-ld-document">JSON-LD
document</a>.
        </p>
      </section>

    </section>

    <section>
      <h2>Revision History</h2>

      <p>
This section contains the substantive changes that have been made to this
specification over time.
      </p>

      <p>
Changes since the
<a href="https://www.w3.org/TR/2022/REC-vc-data-model-20220303/">
v1.1 Recommendation</a>:
      </p>
      <ul>
        <li>
Many editorial updates and fixes to modernize the specification and make
it easier to understand particular concepts.
        </li>
        <li>
Clarify how issuer validation occurs.
        </li>
        <li>
Clarify requirements for securing mechanism extension points.
        </li>
        <li>
Add dependency on [[?INFRA]] for algorithm section.
        </li>
        <li>
Add requirements for securing mechanism specifications.
        </li>
        <li>
Clarify how to perform credential type-specific processing.
        </li>
        <li>
Add mechanism to embed enveloped verifiable credentials in verifiable
presentations.
        </li>
        <li>
Add verification algorithm, interface to securing mechanisms, and
ProblemDetails objects.
        </li>
        <li>
Fine tune allowable values for `issuer` property.
        </li>
        <li>
Provide more concrete guidance on how to express language information as well as
default language and direction.
        </li>
        <li>
Add new conformance classes for issuer and verifier implementations.
        </li>
        <li>
Add new Security Considerations regarding key management.
        </li>
        <li>
Add new Privacy Considerations for trust boundaries, metadata-based correlation,
data theft, and use of Oblivious HTTP.
        </li>
        <li>
Formally define base classes and properties for vocabulary.
        </li>
        <li>
Provide warnings around not using advanced JSON-LD features in order to
maximize interoperability.
        </li>
        <li>
Provide more explicit guidance around sets and arrays.
        </li>
        <li>
Add support for `name` and `description` fields for issuers and credentials.
        </li>
        <li>
Add security considerations around interception, replay, and spoofing attacks.
        </li>
        <li>
Add JWT and SD-JWT claims to base JSON-LD Context.
        </li>
        <li>
Clarify the difference between a "credential" and a "verifiable credential".
        </li>
        <li>
Add section on how to ensure ecosystem compatibility.
        </li>
        <li>
Add section on credential-type-specific processing.
        </li>
        <li>
Add section on validation and relevance to holders.
        </li>
        <li>
Add section on media type precision and interpretation.
        </li>
        <li>
Ensure that `dateTimeStamp` is used for time values. Provide further guidance
on proper usage of time values and timezones.
        </li>
        <li>
Make `validFrom` optional.
        </li>
        <li>
Add `relatedResource` feature.
        </li>
        <li>
Make base context and vocabularies normative and provide cryptographic hashes
for their content.
        </li>
        <li>
Add `renderMethod` and `confidenceMethod` to list of reserved properties.
        </li>
        <li>
Modernize examples in the specification.
        </li>
        <li>
Add "Getting Started" section.
        </li>
        <li>
Add table of reserved properties for properties that are not yet standardized
or are at risk for removal.
        </li>
        <li>
Restrict data model serialization to JSON-LD in compacted document form.
        </li>
        <li>
Update ZKP section to remove older content.
        </li>
        <li>
Add `termsOfUse` to presentations in v2 context.
        </li>
        <li>
Add default vocabulary for undefined terms to v2 context.
        </li>
        <li>
Add media types for `application/vc+ld+json` and `application/vp+ld+json`.
        </li>
        <li>
Provide guidance on converting to and from conforming documents from other
digital credential formats.
        </li>
        <li>
Change reference to URI/IRI to use WHATWG URL specification.
        </li>
        <li>
Add normative dependency on Data Integrity and JOSE/COSE securing mechanisms.
        </li>
        <li>
Rename `issuanceDate`/`expirationDate` to `validFrom`/`validUntil`.
        </li>
        <li>
Add JSON Schema support and update examples to use new format.
        </li>
        <li>
Clarify that `credentialSubject` values cannot be strings.
        </li>
        <li>
Create more formal vocabulary document that refers to this specification.
        </li>
        <li>
Define v2.0 JSON-LD Context.
        </li>
        <li>
Migrate VC-JWT section to separate securing specification.
        </li>
        <li>
Move Subject-Holder relationships to Verifiable Credential implementation guide.
        </li>
        <li>
Increment version number to v2.0 and remove prior REC-track comments.
        </li>
        <li>
Add normative dependency on Verifiable Credential Data Integrity specification
[[VC-DATA-INTEGRITY]].
        </li>
        <li>
The section on
<a href="https://www.w3.org/TR/2022/REC-vc-data-model-20220303/#disputes">Disputes</a>
was removed due to lack of implementations in v1.0 and v1.1.
        </li>
      </ul>

      <p>
Changes since the
<a href="https://www.w3.org/TR/2019/REC-vc-data-model-20191119/">
v1.0 Recommendation</a>:
      </p>
      <ul>
        <li>
Add this revision history section.
        </li>

        <li>
Update previous normative references that pointed to RFC3339 for datetime
details to now normatively reference the datetime details described in
XMLSCHEMA11-2 which more accurately reflects the usage in examples and
libraries.
        </li>

        <li>
Loosen the requirement to allow [=URLs=] that cannot be dereferenced in the
`id` property of the `credentialStatus` and
`refreshService` sections of the data model.
        </li>

        <li>
Loosen normative statements in the zero-knowledge proofs section to enable
compliance of new zero-knowledge proof schemes, such as BBS+, that have been
created since the v1.0 specification was published as a Recommendation.
        </li>

        <li>
Update all references to point to the latest version of the referenced
specifications. Fix broken links to papers that have become unavailable to
updated locations where the papers are available.
        </li>

        <li>
Increase accessibility of SVG diagrams.
        </li>

        <li>
Fix editorial bugs in a few examples related to `issuer`, `issuanceDate`,
`credentialStatus`, dates, dead links, and minor syntax errors.
        </li>

        <li>
Move acknowledgements from Status of the Document section into the
Acknowledgements appendix.
        </li>
      </ul>
    </section>

    <section class="appendix informative">
      <h2>Acknowledgements</h2>

      <p>
The Working Group thanks the following individuals not only for their
contributions toward the content of this document, but also for yeoman's work
in this standards community that drove changes, discussion, and consensus among
a sea of varied opinions: Matt Stone, Gregg Kellogg, Ted Thibodeau Jr, Oliver
Terbu, Joe Andrieu, David I. Lehn, Matthew Collier, and Adrian Gropper.
      </p>

      <p>
Work on this specification has been supported by the Rebooting the
Web of Trust community facilitated by Christopher Allen, Shannon Appelcline,
Kiara Robles, Brian Weller, Betty Dhamers, Kaliya Young, Manu Sporny,
Drummond Reed, Joe Andrieu, Heather Vescent, Kim Hamilton Duffy, Samantha Chase,
and Andrew Hughes. The participants in the Internet Identity Workshop,
facilitated by Phil Windley, Kaliya Young, Doc Searls, and Heidi Nobantu Saul,
also supported the refinement of this work through numerous working sessions
designed to educate about, debate on, and improve this specification.
      </p>

      <p>
The Working Group also thanks our Chairs, Dan Burnett, Matt Stone, Brent Zundel,
Wayne Chang, and Kristina Yasuda as well as our W3C Staff Contacts, Kazuyuki
Ashimura and Ivan Herman, for their expert management and steady guidance of the
group through the W3C standardization process.
      </p>

      <p>
Portions of the work on this specification have been funded by the
United States Department of Homeland Security's Science and Technology
Directorate under contract HSHQDC-17-C-00019. The content of this specification
does not necessarily reflect the position or the policy of the U.S. Government
and no official endorsement should be inferred.
      </p>

      <p>
The Working Group would like to thank the following individuals for reviewing
and providing feedback on the specification (in alphabetical order):
      </p>

      <p>
Christopher Allen, David Ammouial, Joe Andrieu, Bohdan Andriyiv, Ganesh
Annan, Kazuyuki Ashimura, Tim Bouma, Pelle Braendgaard, Dan Brickley,
Allen Brown, Jeff Burdges, Daniel Burnett, ckennedy422, David Chadwick,
Chaoxinhu, Kim (Hamilton) Duffy, Lautaro Dragan, enuoCM, Ken Ebert, Eric
Elliott, William Entriken, David Ezell, Nathan George, Reto Gmür, Ryan
Grant, glauserr, Adrian Gropper, Joel Gustafson, Amy Guy, Lovesh
Harchandani, Daniel Hardman, Dominique Hazael-Massieux, Jonathan Holt,
David Hyland-Wood, Iso5786, Renato Iannella, Richard Ishida, Ian Jacobs,
Anil John, Tom Jones, Rieks Joosten, Gregg Kellogg, Kevin, Eric Korb,
David I. Lehn, Michael Lodder, Dave Longley, Christian Lundkvist, Jim
Masloski, Pat McBennett, Adam C. Migus, Liam Missin, Alexander Mühle,
Anthony Nadalin, Clare Nelson, Mircea Nistor, Grant Noble, Darrell
O'Donnell, Nate Otto, Matt Peterson, Addison Phillips, Eric Prud'hommeaux,
Liam Quin, Rajesh Rathnam, Drummond Reed, Yancy Ribbens, Justin Richer,
Evstifeev Roman, RorschachRev, Steven Rowat, Pete Rowley, Markus
Sabadello, Kristijan Sedlak, Tzviya Seigman, Reza Soltani, Manu Sporny,
Orie Steele, Matt Stone, Oliver Terbu, Ted Thibodeau Jr, John Tibbetts,
Mike Varley, Richard Varn, Heather Vescent, Christopher Lemmer Webber,
Benjamin Young, Kaliya Young, Dmitri Zagidulin, and Brent Zundel.
      </p>
    </section>
  </body>
</html>
